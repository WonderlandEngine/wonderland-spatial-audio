/**
 * Types
 */
/// <reference types="webxr" />
import { WonderlandEngine } from './engine.js';
import { Emitter } from './utils/event.js';
import { ComponentProperty } from './property.js';
/**
 * A type alias for any TypedArray constructor, except big-int arrays.
 */
export type TypedArrayCtor = Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
/**
 * Typed array instance based on a given {@link TypedArrayCtor} constructor.
 *
 * @typeParam T - The TypedArray constructor.
 */
export type TypedArray<T extends TypedArrayCtor = TypedArrayCtor> = InstanceType<T>;
/**
 * Represents any object that can be used as an array for read / write.
 */
export interface NumberArray {
    length: number;
    [n: number]: number;
}
/**
 * Type to describe a constructor.
 */
export type Constructor<T = any> = {
    new (...args: any[]): T;
};
/**
 * Component constructor type.
 *
 * For more information, please have a look at the {@link Component} class.
 */
export type ComponentConstructor<T extends Component = Component> = Constructor<T> & {
    TypeName: string;
    Properties: Record<string, ComponentProperty>;
    /** @deprecated @hidden */
    Dependencies?: ComponentConstructor[];
    onRegister?: (engine: WonderlandEngine) => void;
};
/**
 * Component prototype interface.
 *
 * User component's should have the same structure.
 */
export interface ComponentProto {
    /**
     * Triggered after the component instantiation.
     * For more information, please have a look at {@link Component.init}.
     */
    init?: () => void;
    /**
     * Triggered after the component is activated for the first time.
     * For more information, please have a look at {@link Component.start}.
     */
    start?: () => void;
    /**
     * Triggered once per frame.
     * For more information, please have a look at {@link Component.update}.
     *
     * @param dt Delta time, time since last update.
     */
    update?: (dt: number) => void;
    /**
     * Triggered when the component goes from deactivated to activated.
     * For more information, please have a look at {@link Component.onActivate}.
     */
    onActivate?: () => void;
    /**
     * Triggered when the component goes from activated to deactivated.
     * For more information, please have a look at {@link Component.onDeactivate}.
     */
    onDeactivate?: () => void;
    /**
     * Triggered when the component is removed from its object.
     * For more information, please have a look at {@link Component.onDestroy}.
     *
     * @since 0.9.0
     */
    onDestroy?: () => void;
}
/** Extension data obtained from glTF files. */
export interface GLTFExtensions {
    /** glTF root extensions object. JSON data indexed by extension name. */
    root: Record<string, Record<string, any>>;
    /**
     * Mesh extension objects. Key is {@link Object3D.objectId}, value is JSON
     * data indexed by extension name.
     */
    mesh: Record<number, Record<string, Record<string, any>>>;
    /**
     * Node extension objects. Key is {@link Object3D.objectId}, value is JSON
     * data indexed by extension name.
     */
    node: Record<number, Record<string, Record<string, any>>>;
    /** Remapping from glTF node index to {@link Object3D.objectId}. */
    idMapping: number[];
}
/** Options for {@link Scene.append}. */
export interface SceneAppendParameters {
    /** Whether to load glTF extension data */
    loadGltfExtensions: boolean;
}
/**
 * Result obtained when appending a scene with {@link Scene.append}.
 */
export type SceneAppendResult = (Object3D | null) | {
    root: Object3D | null;
    extensions: GLTFExtensions;
};
/**
 * Callback triggered on collision event.
 *
 * @param type Type of the event.
 * @param other Other component that was (un)collided with
 */
export type CollisionCallback = (type: CollisionEventType, other: PhysXComponent) => void;
/**
 * Wonderland Engine API
 * @namespace WL
 */
/**
 * Collider type enum for {@link CollisionComponent}.
 */
export declare enum Collider {
    /**
     * **Sphere Collider**:
     *
     * Simplest and most performant collision shape. If this type is set on a
     * {@link CollisionComponent}, only the first component of
     * {@link CollisionComponent#extents} will be used to determine the radius.
     */
    Sphere = 0,
    /**
     * **Axis Aligned Bounding Box Collider**:
     *
     * Box that is always aligned to XYZ axis. It cannot be rotated but is more
     * efficient than {@link Collider.Box}.
     */
    AxisAlignedBox = 1,
    /**
     * **Aligned Bounding Box Collider**:
     *
     * Box that matches the object's rotation and translation correctly. This
     * is the least efficient collider and should only be chosen over
     * {@link Collider.Sphere} and {@link Collider.AxisAlignedBox} if really
     * necessary.
     */
    Box = 2
}
/**
 * Alignment type enum for {@link TextComponent}.
 */
export declare enum Alignment {
    /** Text start is at object origin */
    Left = 0,
    /** Text center is at object origin */
    Center = 1,
    /** Text end is at object origin */
    Right = 2
}
/**
 * Justification type enum for {@link TextComponent}.
 */
export declare enum Justification {
    /** Text line is at object origin */
    Line = 0,
    /** Text middle is at object origin */
    Middle = 1,
    /** Text top is at object origin */
    Top = 2,
    /** Text bottom is at object origin */
    Bottom = 3
}
/**
 * Effect type enum for {@link TextComponent}.
 */
export declare enum TextEffect {
    /** Text is rendered normally */
    None = 0,
    /** Text is rendered with an outline */
    Outline = 1
}
/**
 * Input type enum for {@link InputComponent}.
 */
export declare enum InputType {
    /** Head input */
    Head = 0,
    /** Left eye input */
    EyeLeft = 1,
    /** Right eye input */
    EyeRight = 2,
    /** Left controller input */
    ControllerLeft = 3,
    /** Right controller input */
    ControllerRight = 4,
    /** Left ray input */
    RayLeft = 5,
    /** Right ray input */
    RayRight = 6
}
/**
 * Light type enum for {@link LightComponent}.
 */
export declare enum LightType {
    /** Point light */
    Point = 0,
    /** Spot light */
    Spot = 1,
    /** Sun light / Directional light */
    Sun = 2
}
/**
 * Animation state of {@link AnimationComponent}.
 */
export declare enum AnimationState {
    /** Animation is currently playing */
    Playing = 0,
    /** Animation is paused and will continue at current playback
     * time on {@link AnimationComponent#play} */
    Paused = 1,
    /** Animation is stopped */
    Stopped = 2
}
/**
 * Rigid body force mode for {@link PhysXComponent#addForce} and {@link PhysXComponent#addTorque}.
 *
 * [PhysX API Reference](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/structPxForceMode.html)
 */
export declare enum ForceMode {
    /** Apply as force */
    Force = 0,
    /** Apply as impulse */
    Impulse = 1,
    /** Apply as velocity change, mass dependent */
    VelocityChange = 2,
    /** Apply as mass dependent force */
    Acceleration = 3
}
/**
 * Collision callback event type.
 */
export declare enum CollisionEventType {
    /** Touch/contact detected, collision */
    Touch = 0,
    /** Touch/contact lost, uncollide */
    TouchLost = 1,
    /** Touch/contact with trigger detected */
    TriggerTouch = 2,
    /** Touch/contact with trigger lost */
    TriggerTouchLost = 3
}
/**
 * Rigid body {@link PhysXComponent#shape}.
 *
 * [PhysX SDK Guide](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html#geometry-types).
 */
export declare enum Shape {
    /** No shape. */
    None = 0,
    /** Sphere shape. */
    Sphere = 1,
    /** Capsule shape. */
    Capsule = 2,
    /** Box shape. */
    Box = 3,
    /** Plane shape. */
    Plane = 4,
    /** Convex mesh shape. */
    ConvexMesh = 5,
    /** Triangle mesh shape. */
    TriangleMesh = 6
}
/**
 * Mesh attribute enum.
 * @since 0.9.0
 */
export declare enum MeshAttribute {
    /** Position attribute, 3 floats */
    Position = 0,
    /** Tangent attribute, 4 floats */
    Tangent = 1,
    /** Normal attribute, 3 floats */
    Normal = 2,
    /** Texture coordinate attribute, 2 floats */
    TextureCoordinate = 3,
    /** Color attribute, 4 floats, RGBA, range `0` to `1` */
    Color = 4,
    /** Joint id attribute, 8 unsigned ints */
    JointId = 5,
    /** Joint weights attribute, 8 floats */
    JointWeight = 6
}
/**
 * Material parameter type.
 */
export declare enum MaterialParamType {
    /** Unsigned integer parameter type. */
    UnsignedInt = 0,
    /** Integer parameter type. */
    Int = 1,
    /** Float parameter type. */
    Float = 2,
    /** Sampler resource parameter type, i.e., a {@link Texture}. */
    Sampler = 3,
    /**
     * Font resource parameter type.
     *
     * **Note**: Changing font isn't exposed yet and will raise an error.
     */
    Font = 4
}
/**
 * Provides global scene functionality like raycasting.
 */
export declare class Scene {
    /** Called before rendering the scene */
    readonly onPreRender: Emitter<void[]>;
    /** Called after the scene has been rendered */
    readonly onPostRender: Emitter<void[]>;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /** Ray hit pointer in WASM heap. @hidden */
    private _rayHit;
    /** Ray hit. @hidden */
    private _hit;
    constructor(engine: WonderlandEngine);
    /**
     * Currently active view components.
     */
    get activeViews(): ViewComponent[];
    /**
     * Cast a ray through the scene and find intersecting objects.
     *
     * The resulting ray hit will contain up to **4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     *
     * @returns The scene cached {@link RayHit} instance.
     * @note The returned object is owned by the Scene instance
     *   will be reused with the next {@link Scene#rayCast} call.
     */
    rayCast(o: Readonly<NumberArray>, d: Readonly<NumberArray>, group: number): RayHit;
    /**
     * Add an object to the scene.
     *
     * @param parent Parent object or `null`.
     * @returns A newly created object.
     */
    addObject(parent?: Object3D | null): Object3D;
    /**
     * Batch-add objects to the scene.
     *
     * Will provide better performance for adding multiple objects (e.g. > 16)
     * than calling {@link Scene#addObject} repeatedly in a loop.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * convervatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param count Number of objects to add.
     * @param parent Parent object or `null`, default `null`.
     * @param componentCountHint Hint for how many components in total will
     *      be added to the created objects afterwards, default `0`.
     * @returns Newly created objects
     */
    addObjects(count: number, parent?: Object3D | null, componentCountHint?: number): Object3D[];
    /**
     * Pre-allocate memory for a given amount of objects and components.
     *
     * Will provide better performance for adding objects later with {@link Scene#addObject}
     * and {@link Scene#addObjects}.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * conservatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param objectCount Number of objects to add.
     * @param componentCountPerType Amount of components to
     *      allocate for {@link Object3D.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
     * @since 0.8.10
     */
    reserveObjects(objectCount: number, componentCountPerType: Record<string, number>): void;
    /**
     * Set the background clear color.
     *
     * @param color new clear color (RGBA).
     * @since 0.8.5
     */
    set clearColor(color: number[]);
    /**
     * Set whether to clear the color framebuffer before drawing.
     *
     * This function is useful if an external framework (e.g. an AR tracking
     * framework) is responsible for drawing a camera frame before Wonderland
     * Engine draws the scene on top of it.
     *
     * @param b Whether to enable color clear.
     * @since 0.9.4
     */
    set colorClearEnabled(b: boolean);
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * Load a scene file (.bin).
     *
     * Will replace the currently active scene with the one loaded
     * from given file. It is assumed that JavaScript components required by
     * the new scene were registered in advance.
     *
     * Once the scene is loaded successfully and initialized,
     * {@link WonderlandEngine.onSceneLoaded} is notified.
     *
     * @param filename Path to the .bin file.
     * @returns Promise that resolves when the scene was loaded.
     */
    load(filename: string): Promise<void>;
    /**
     * Append a scene file.
     *
     * Loads and parses the file and its images and appends the result
     * to the currently active scene.
     *
     * Supported formats are streamable Wonderland scene files (.bin) and glTF
     * 3D scenes (.gltf, .glb).
     *
     * ```js
     * WL.scene.append(filename).then(root => {
     *     // root contains the loaded scene
     * });
     * ```
     *
     * In case the `loadGltfExtensions` option is set to true, the response
     * will be an object containing both the root of the loaded scene and
     * any glTF extensions found on nodes, meshes and the root of the file.
     *
     * ```js
     * WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {
     *     // root contains the loaded scene
     *     // extensions.root contains any extensions at the root of glTF document
     *     const rootExtensions = extensions.root;
     *     // extensions.mesh and extensions.node contain extensions indexed by Object id
     *     const childObject = root.children[0];
     *     const meshExtensions = root.meshExtensions[childObject.objectId];
     *     const nodeExtensions = root.nodeExtensions[childObject.objectId];
     *     // extensions.idMapping contains a mapping from glTF node index to Object id
     * });
     * ```
     *
     * @param file The .bin, .gltf or .glb file to append. Should be a URL or
     *   an `ArrayBuffer` with the file content.
     * @param options Additional options for loading.
     * @returns Promise that resolves when the scene was appended.
     */
    append(file: string | ArrayBuffer, options?: Partial<SceneAppendParameters>): Promise<SceneAppendResult>;
    /**
     * Unmarshalls the GltfExtensions from an Uint32Array.
     *
     * @param data Array containing the gltf extension data.
     * @returns The extensions stored in an object literal.
     *
     * @hidden
     */
    _unmarshallGltfExtensions(data: Uint32Array): GLTFExtensions;
    /**
     * Reset the scene.
     *
     * This method deletes all used and allocated objects, and components.
     */
    reset(): void;
}
/**
 * Native component
 *
 * Provides access to a native component instance of a specified component type.
 *
 * Usage example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 *
 * export class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *     };
 *     start() {}
 *     onActivate() {}
 *     onDeactivate() {}
 *     update(dt) {}
 * }
 * ```
 */
export declare class Component {
    /**
     * Unique identifier for this component class.
     *
     * This is used to register, add, and retrieve components of a given type.
     */
    static TypeName: string;
    /**
     * Properties of this component class.
     *
     * Properties are public attributes that can be configured via the
     * Wonderland Editor.
     *
     * Example:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     * class MyComponent extends Component {
     *     static TypeName = 'my-component';
     *     static Properties = {
     *         myBoolean: { type: Type.Boolean, default: false },
     *         myFloat: { type: Type.Float, default: false },
     *         myTexture: { type: Type.Texture, default: null },
     *     };
     * }
     * ```
     *
     * Properties are automatically added to each component instance, and are
     * accessible like any JS attribute:
     *
     * ```js
     * // Creates a new component and set each properties value:
     * const myComponent = object.addComponent(MyComponent, {
     *     myBoolean: true,
     *     myFloat: 42.0,
     *     myTexture: null
     * });
     *
     * // You can also override the properties on the instance:
     * myComponent.myBoolean = false;
     * myComponent.myFloat = -42.0;
     * ```
     */
    static Properties: Record<string, ComponentProperty>;
    /**
     * This was never released in an official version, we are keeping it
     * to easy transition to the new API.
     *
     * @deprecated Use {@link Component.onRegister} instead.
     * @hidden
     */
    static Dependencies?: ComponentConstructor[];
    /**
     * Called when this component class is registered.
     *
     * @example
     *
     * This callback can be used to register dependencies of a component,
     * e.g., component classes that need to be registered in order to add
     * them at runtime with {@link Object3D.addComponent}, independent of whether
     * they are used in the editor.
     *
     * ```js
     * class Spawner extends Component {
     *     static TypeName = 'spawner';
     *
     *     static onRegister() {
     *         engine.registerComponent(SpawnedComponent);
     *     }
     *
     *     // You can now use addComponent with SpawnedComponent
     * }
     * ```
     *
     * @example
     *
     * This callback can be used to register different implementations of a
     * component depending on client features or API versions.
     *
     * ```js
     * // Properties need to be the same for all implementations!
     * const SharedProperties = {};
     *
     * class Anchor extends Component {
     *     static TypeName = 'spawner';
     *     static Properties = SharedProperties;
     *
     *     static onRegister() {
     *         if(navigator.xr === undefined) {
     *             /* WebXR unsupported, keep this dummy component *\/
     *             return;
     *         }
     *         /* WebXR supported! Override already registered dummy implementation
     *          * with one depending on hit-test API support *\/
     *         engine.registerComponent(window.HitTestSource === undefined ?
     *             AnchorWithoutHitTest : AnchorWithHitTest);
     *     }
     *
     *     // This one implements no functions
     * }
     * ```
     */
    static onRegister?: (engine: WonderlandEngine) => void;
    /**
     * Triggered when the component is initialized by the runtime. This method
     * will only be triggered **once** after instantiation.
     */
    init?(): void;
    /**
     * Triggered when the component is started by the runtime, or activated.
     *
     * You can use that to re-initialize the state of the component.
     */
    start?(): void;
    /**
     * Triggered  **every frame** by the runtime.
     *
     * You should perform your business logic in this method. Example:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     *
     * class TranslateForwardComponent extends Component {
     *     static TypeName = 'translate-forward-component';
     *     static Properties = {
     *         speed: { type: Type.Float, default: 1.0 }
     *     };
     *     constructor() {
     *         this._forward = new Float32Array([0, 0, 0]);
     *     }
     *     update(dt) {
     *         this.object.getForward(this._forward);
     *         this._forward[0] *= this.speed;
     *         this._forward[1] *= this.speed;
     *         this._forward[2] *= this.speed;
     *         this.object.translate(this._forward);
     *     }
     * }
     * ```
     *
     * @param delta Elapsed time between this frame and the previous one, in **seconds**.
     */
    update?(delta: number): void;
    /**
     * Triggered when the component goes from an inactive state to an active state.
     *
     * @note You can manually activate or deactivate a component using: {@link Component.active:setter}.
     */
    onActivate?(): void;
    /**
     * Triggered when the component goes from an activated state to an inactive state.
     *
     * @note You can manually activate or deactivate a component using: {@link Component.active:setter}.
     */
    onDeactivate?(): void;
    /**
     * Triggered when the component is removed from its object.
     *
     * @note You can remove a component using: {@link Component.destroy}.
     *
     * @since 0.9.0
     */
    onDestroy?(): void;
    /** Manager index. @hidden */
    readonly _manager: number;
    /** Instance index. @hidden */
    readonly _id: number;
    /**
     * Object containing this object.
     *
     * **Note**: This is cached for faster retrieval.
     *
     * @hidden
     */
    _object: Object3D | null;
    /** Wonderland Engine instance. @hidden */
    protected readonly _engine: WonderlandEngine;
    /**
     * Create a new instance
     *
     * @param engine The engine instance.
     * @param manager Index of the manager.
     * @param id WASM component instance index.
     *
     * @hidden
     */
    constructor(engine: WonderlandEngine, manager?: number, id?: number);
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /** The name of this component's type */
    get type(): string;
    /** The object this component is attached to. */
    get object(): Object3D;
    /**
     * Set whether this component is active.
     *
     * Activating/deactivating a component comes at a small cost of reordering
     * components in the respective component manager. This function therefore
     * is not a trivial assignment.
     *
     * Does nothing if the component is already activated/deactivated.
     *
     * @param active New active state.
     */
    set active(active: boolean);
    /**
     * Whether this component is active
     */
    get active(): boolean;
    /**
     * Remove this component from its objects and destroy it.
     *
     * It is best practice to set the component to `null` after,
     * to ensure it does not get used later.
     *
     * ```js
     *    c.destroy();
     *    c = null;
     * ```
     * @since 0.9.0
     */
    destroy(): void;
    /**
     * Checks equality by comparing whether the wrapped native component ids
     * and component manager types are equal.
     *
     * @param otherComponent Component to check equality with.
     * @returns Whether this component equals the given component.
     */
    equals(otherComponent: Component | undefined | null): boolean;
}
/**
 * Native collision component.
 *
 * Provides access to a native collision component instance.
 */
export declare class CollisionComponent extends Component {
    /** @override */
    static TypeName: string;
    /** Collision component collider */
    get collider(): Collider;
    /**
     * Set collision component collider.
     *
     * @param collider Collider of the collision component.
     */
    set collider(collider: Collider);
    /**
     * Collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the returned vector is used.
     */
    get extents(): Float32Array;
    /**
     * Set collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the passed vector is used.
     *
     * Example:
     *
     * ```js
     * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
     * collision.extent = [1, 2, 3];
     * ```
     *
     * @param extents Extents of the collision component, expects a
     *      3 component array.
     */
    set extents(extents: Readonly<NumberArray>);
    /**
     * Collision component group.
     *
     * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
     * or the group in {@link Scene#rayCast}.
     *
     * Colliders that have no common groups will not overlap with each other. If a collider
     * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
     *
     * Each bit represents belonging to a group, see example.
     *
     * ```js
     *    // c belongs to group 2
     *    c.group = (1 << 2);
     *
     *    // c belongs to group 0
     *    c.group = (1 << 0);
     *
     *    // c belongs to group 0 *and* 2
     *    c.group = (1 << 0) | (1 << 2);
     *
     *    (c.group & (1 << 2)) != 0; // true
     *    (c.group & (1 << 7)) != 0; // false
     * ```
     */
    get group(): number;
    /**
     * Set collision component group.
     *
     * @param group Group mask of the collision component.
     */
    set group(group: number);
    /**
     * Query overlapping objects.
     *
     * Usage:
     *
     * ```js
     * const collision = object.getComponent('collision');
     * const overlaps = collision.queryOverlaps();
     * for(const otherCollision of overlaps) {
     *     const otherObject = otherCollision.object;
     *     console.log(`Collision with object ${otherObject.objectId}`);
     * }
     * ```
     *
     * @returns Collision components overlapping this collider.
     */
    queryOverlaps(): CollisionComponent[];
}
/**
 * Native text component
 *
 * Provides access to a native text component instance
 */
export declare class TextComponent extends Component {
    /** @override */
    static TypeName: string;
    /** Text component alignment. */
    get alignment(): Alignment;
    /**
     * Set text component alignment.
     *
     * @param alignment Alignment for the text component.
     */
    set alignment(alignment: Alignment);
    /** Text component justification. */
    get justification(): Justification;
    /**
     * Set text component justification.
     *
     * @param justification Justification for the text component.
     */
    set justification(justification: Justification);
    /** Text component character spacing. */
    get characterSpacing(): number;
    /**
     * Set text component character spacing.
     *
     * @param spacing Character spacing for the text component.
     */
    set characterSpacing(spacing: number);
    /** Text component line spacing. */
    get lineSpacing(): number;
    /**
     * Set text component line spacing
     *
     * @param spacing Line spacing for the text component
     */
    set lineSpacing(spacing: number);
    /** Text component effect. */
    get effect(): TextEffect;
    /**
     * Set text component effect
     *
     * @param effect Effect for the text component
     */
    set effect(effect: TextEffect);
    /** Text component text. */
    get text(): string;
    /**
     * Set text component text.
     *
     * @param text Text of the text component.
     */
    set text(text: string);
    /**
     * Set material to render the text with.
     *
     * @param material New material.
     */
    set material(material: Material | null | undefined);
    /** Material used to render the text. */
    get material(): Material | null;
}
/**
 * Native view component.
 *
 * Provides access to a native view component instance.
 */
export declare class ViewComponent extends Component {
    /** @override */
    static TypeName: string;
    /** Projection matrix. */
    get projectionMatrix(): Float32Array;
    /** ViewComponent near clipping plane value. */
    get near(): number;
    /**
     * Set near clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param near Near depth value.
     */
    set near(near: number);
    /** Far clipping plane value. */
    get far(): number;
    /**
     * Set far clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param far Near depth value.
     */
    set far(far: number);
    /**
     * Get the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, this returns the field of view reported by
     * the device, regardless of the fov that was set.
     */
    get fov(): number;
    /**
     * Set the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, the field of view reported by the device is
     * used and this value is ignored. After the XR session ends, the new value
     * is applied.
     *
     * @param fov Horizontal field of view, **in degrees**.
     */
    set fov(fov: number);
}
/**
 * Native input component.
 *
 * Provides access to a native input component instance.
 */
export declare class InputComponent extends Component {
    /** @override */
    static TypeName: string;
    /** Input component type */
    get inputType(): InputType;
    /**
     * Set input component type.
     *
     * @params New input component type.
     */
    set inputType(type: InputType);
    /**
     * WebXR Device API input source associated with this input component,
     * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
     */
    get xrInputSource(): XRInputSource | null;
    /**
     * 'left', 'right' or `null` depending on the {@link InputComponent#inputType}.
     */
    get handedness(): 'left' | 'right' | null;
}
/**
 * Native light component.
 *
 * Provides access to a native light component instance.
 */
export declare class LightComponent extends Component {
    /** @override */
    static TypeName: string;
    /** @overload */
    getColor(): Float32Array;
    /**
     * Get light color.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @returns The `out` parameter.
     * @since 1.0.0
     */
    getColor<T extends NumberArray>(out: T): T;
    /**
     * Set light color.
     *
     * @param c New color array/vector, expected to have at least 3 elements.
     * @since 1.0.0
     */
    setColor(c: Readonly<NumberArray>): void;
    /**
     * View on the light color.
     *
     * @note Prefer to use {@link getColor} in performance-critical code.
     */
    get color(): Float32Array;
    /**
     * Set light color.
     *
     * @param c Color of the light component.
     *
     * @note Prefer to use {@link setColor} in performance-critical code.
     */
    set color(c: Readonly<NumberArray>);
    /** Light type. */
    get lightType(): LightType;
    /**
     * Set light type.
     *
     * @param lightType Type of the light component.
     */
    set lightType(t: LightType);
    /**
     * Light intensity.
     * @since 1.0.0
     */
    get intensity(): number;
    /**
     * Set light intensity.
     *
     * @param intensity Intensity of the light component.
     * @since 1.0.0
     */
    set intensity(intensity: number);
    /**
     * Outer angle for spot lights, in degrees.
     * @since 1.0.0
     */
    get outerAngle(): number;
    /**
     * Set outer angle for spot lights.
     *
     * @param angle Outer angle, in degrees.
     * @since 1.0.0
     */
    set outerAngle(angle: number);
    /**
     * Inner angle for spot lights, in degrees.
     * @since 1.0.0
     */
    get innerAngle(): number;
    /**
     * Set inner angle for spot lights.
     *
     * @param angle Inner angle, in degrees.
     * @since 1.0.0
     */
    set innerAngle(angle: number);
    /**
     * Whether the light casts shadows.
     * @since 1.0.0
     */
    get shadows(): boolean;
    /**
     * Set whether the light casts shadows.
     *
     * @param b Whether the light casts shadows.
     * @since 1.0.0
     */
    set shadows(b: boolean);
    /**
     * Range for shadows.
     * @since 1.0.0
     */
    get shadowRange(): number;
    /**
     * Set range for shadows.
     *
     * @param range Range for shadows.
     * @since 1.0.0
     */
    set shadowRange(range: number);
    /**
     * Bias value for shadows.
     * @since 1.0.0
     */
    get shadowBias(): number;
    /**
     * Set bias value for shadows.
     *
     * @param bias Bias for shadows.
     * @since 1.0.0
     */
    set shadowBias(bias: number);
    /**
     * Normal bias value for shadows.
     * @since 1.0.0
     */
    get shadowNormalBias(): number;
    /**
     * Set normal bias value for shadows.
     *
     * @param bias Normal bias for shadows.
     * @since 1.0.0
     */
    set shadowNormalBias(bias: number);
    /**
     * Texel size for shadows.
     * @since 1.0.0
     */
    get shadowTexelSize(): number;
    /**
     * Set texel size for shadows.
     *
     * @param size Texel size for shadows.
     * @since 1.0.0
     */
    set shadowTexelSize(size: number);
    /**
     * Cascade count for {@link LightType.Sun} shadows.
     * @since 1.0.0
     */
    get cascadeCount(): number;
    /**
     * Set cascade count for {@link LightType.Sun} shadows.
     *
     * @param count Cascade count.
     * @since 1.0.0
     */
    set cascadeCount(count: number);
}
/**
 * Native animation component.
 *
 * Provides access to a native animation component instance.
 */
export declare class AnimationComponent extends Component {
    /** @override */
    static TypeName: string;
    /**
     * Set animation to play.
     *
     * Make sure to {@link Animation#retarget} the animation to affect the
     * right objects.
     *
     * @param anim Animation to play.
     */
    set animation(anim: Animation | null | undefined);
    /** Animation set for this component */
    get animation(): Animation | null;
    /**
     * Set play count. Set to `0` to loop indefinitely.
     *
     * @param playCount Number of times to repeat the animation.
     */
    set playCount(playCount: number);
    /** Number of times the animation is played. */
    get playCount(): number;
    /**
     * Set speed. Set to negative values to run the animation backwards.
     *
     * Setting speed has an immediate effect for the current frame's update
     * and will continue with the speed from the current point in the animation.
     *
     * @param speed New speed at which to play the animation.
     * @since 0.8.10
     */
    set speed(speed: number);
    /**
     * Speed factor at which the animation is played.
     *
     * @since 0.8.10
     */
    get speed(): number;
    /** Current playing state of the animation */
    get state(): AnimationState;
    /**
     * Play animation.
     *
     * If the animation is currently paused, resumes from that position. If the
     * animation is already playing, does nothing.
     *
     * To restart the animation, {@link AnimationComponent#stop} it first.
     */
    play(): void;
    /** Stop animation. */
    stop(): void;
    /** Pause animation. */
    pause(): void;
}
/**
 * Native mesh component.
 *
 * Provides access to a native mesh component instance.
 */
export declare class MeshComponent extends Component {
    /** @override */
    static TypeName: string;
    /**
     * Set material to render the mesh with.
     *
     * @param material Material to render the mesh with.
     */
    set material(material: Material | null | undefined);
    /** Material used to render the mesh. */
    get material(): Material | null;
    /** Mesh rendered by this component. */
    get mesh(): Mesh | null;
    /**
     * Set mesh to rendered with this component.
     *
     * @param mesh Mesh rendered by this component.
     */
    set mesh(mesh: Mesh | null | undefined);
    /** Skin for this mesh component. */
    get skin(): Skin | null;
    /**
     * Set skin to transform this mesh component.
     *
     * @param skin Skin to use for rendering skinned meshes.
     */
    set skin(skin: Skin | null | undefined);
}
/**
 * Enum for Physics axes locking
 *
 * See {@link PhysXComponent.angularLockAxis} and {@link PhysXComponent.linearLockAxis}.
 */
export declare enum LockAxis {
    /**
     * No axis selected.
     */
    None = 0,
    /**
     * **X axis**:
     */
    X = 1,
    /**
     * **Y axis**:
     */
    Y = 2,
    /**
     * **Z axis**:
     */
    Z = 4
}
/**
 * Native physx rigid body component.
 *
 * Provides access to a native mesh component instance.
 * Only available when using physx enabled runtime, see "Project Settings > Runtime".
 */
export declare class PhysXComponent extends Component {
    /** @override */
    static TypeName: string;
    /**
     * Set whether this rigid body is static.
     *
     * Setting this property only takes effect once the component
     * switches from inactive to active.
     *
     * @param b Whether the rigid body should be static.
     */
    set static(b: boolean);
    /**
     * Whether this rigid body is static.
     *
     * This property returns whether the rigid body is *effectively*
     * static. If static property was set while the rigid body was
     * active, it will not take effect until the rigid body is set
     * inactive and active again. Until the component is set inactive,
     * this getter will return whether the rigid body is actually
     * static.
     */
    get static(): boolean;
    /**
     * Set whether this rigid body is kinematic.
     *
     * @param b Whether the rigid body should be kinematic.
     */
    set kinematic(b: boolean);
    /**
     * Whether this rigid body is kinematic.
     */
    get kinematic(): boolean;
    /**
     * Set whether this rigid body's gravity is enabled.
     *
     * @param b Whether the rigid body's gravity should be enabled.
     */
    set gravity(b: boolean);
    /**
     * Whether this rigid body's gravity flag is enabled.
     */
    get gravity(): boolean;
    /**
     * Set whether this rigid body's simulate flag is enabled.
     *
     * @param b Whether the rigid body's simulate flag should be enabled.
     */
    set simulate(b: boolean);
    /**
     * Whether this rigid body's simulate flag is enabled.
     */
    get simulate(): boolean;
    /**
     * Set whether to allow simulation of this rigid body.
     *
     * {@link allowSimulation} and {@link trigger} can not be enabled at the
     * same time. Enabling {@link allowSimulation} while {@link trigger} is enabled
     * will disable {@link trigger}.
     *
     * @param b Whether to allow simulation of this rigid body.
     */
    set allowSimulation(b: boolean);
    /**
     * Whether to allow simulation of this rigid body.
     */
    get allowSimulation(): boolean;
    /**
     * Set whether this rigid body may be queried in ray casts.
     *
     * @param b Whether this rigid body may be queried in ray casts.
     */
    set allowQuery(b: boolean);
    /**
     * Whether this rigid body may be queried in ray casts.
     */
    get allowQuery(): boolean;
    /**
     * Set whether this physics body is a trigger.
     *
     * {@link allowSimulation} and {@link trigger} can not be enabled at the
     * same time. Enabling trigger while {@link allowSimulation} is enabled,
     * will disable {@link allowSimulation}.
     *
     * @param b Whether this physics body is a trigger.
     */
    set trigger(b: boolean);
    /**
     * Whether this physics body is a trigger.
     */
    get trigger(): boolean;
    /**
     * Set the shape for collision detection.
     *
     * @param s New shape.
     * @since 0.8.5
     */
    set shape(s: Shape);
    /** The shape for collision detection. */
    get shape(): Shape;
    /**
     * Set additional data for the shape.
     *
     * Retrieved only from {@link PhysXComponent#shapeData}.
     * @since 0.8.10
     */
    set shapeData(d: {
        index: number;
    } | null);
    /**
     * Additional data for the shape.
     *
     * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
     * `{index: n}` for `TriangleMesh` and `ConvexHull`.
     *
     * This data is currently only for passing onto or creating other {@link PhysXComponent}.
     * @since 0.8.10
     */
    get shapeData(): {
        index: number;
    } | null;
    /**
     * Set the shape extents for collision detection.
     *
     * @param e New extents for the shape.
     * @since 0.8.5
     */
    set extents(e: Readonly<NumberArray>);
    /**
     * The shape extents for collision detection.
     */
    get extents(): Float32Array;
    /**
     * Get staticFriction.
     */
    get staticFriction(): number;
    /**
     * Set staticFriction.
     * @param v New staticFriction.
     */
    set staticFriction(v: number);
    /**
     * Get dynamicFriction.
     */
    get dynamicFriction(): number;
    /**
     * Set dynamicFriction
     * @param v New dynamicDamping.
     */
    set dynamicFriction(v: number);
    /**
     * Get bounciness.
     * @since 0.9.0
     */
    get bounciness(): number;
    /**
     * Set bounciness.
     * @param v New bounciness.
     * @since 0.9.0
     */
    set bounciness(v: number);
    /**
     * Get linearDamping/
     */
    get linearDamping(): number;
    /**
     * Set linearDamping.
     * @param v New linearDamping.
     */
    set linearDamping(v: number);
    /** Get angularDamping. */
    get angularDamping(): number;
    /**
     * Set angularDamping.
     * @param v New angularDamping.
     */
    set angularDamping(v: number);
    /**
     * Set linear velocity.
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New linear velocity.
     */
    set linearVelocity(v: Readonly<NumberArray>);
    /** Linear velocity or `[0, 0, 0]` if the component is not active. */
    get linearVelocity(): Float32Array;
    /**
     * Set angular velocity
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New angular velocity
     */
    set angularVelocity(v: Readonly<NumberArray>);
    /** Angular velocity or `[0, 0, 0]` if the component is not active. */
    get angularVelocity(): Float32Array;
    /**
     * Set the components groups mask.
     *
     * @param flags New flags that need to be set.
     */
    set groupsMask(flags: number);
    /**
     * Get the components groups mask flags.
     *
     * Each bit represents membership to group, see example.
     *
     * ```js
     * // Assign c to group 2
     * c.groupsMask = (1 << 2);
     *
     * // Assign c to group 0
     * c.groupsMask  = (1 << 0);
     *
     * // Assign c to group 0 and 2
     * c.groupsMask = (1 << 0) | (1 << 2);
     *
     * (c.groupsMask & (1 << 2)) != 0; // true
     * (c.groupsMask & (1 << 7)) != 0; // false
     * ```
     */
    get groupsMask(): number;
    /**
     * Set the components blocks mask.
     *
     * @param flags New flags that need to be set.
     */
    set blocksMask(flags: number);
    /**
     * Get the components blocks mask flags.
     *
     * Each bit represents membership to the block, see example.
     *
     * ```js
     * // Block overlap with any objects in group 2
     * c.blocksMask = (1 << 2);
     *
     * // Block overlap with any objects in group 0
     * c.blocksMask  = (1 << 0)
     *
     * // Block overlap with any objects in group 0 and 2
     * c.blocksMask = (1 << 0) | (1 << 2);
     *
     * (c.blocksMask & (1 << 2)) != 0; // true
     * (c.blocksMask & (1 << 7)) != 0; // false
     * ```
     */
    get blocksMask(): number;
    /**
     * Set axes to lock for linear velocity.
     *
     * @param lock The Axis that needs to be set.
     *
     * Combine flags with Bitwise OR.
     * ```js
     * body.linearLockAxis = LockAxis.X | LockAxis.Y; // x and y set
     * body.linearLockAxis = LockAxis.X; // y unset
     * ```
     *
     * @note This has no effect if the component is static.
     */
    set linearLockAxis(lock: LockAxis);
    /**
     * Get the linear lock axes flags.
     *
     * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
     *
     * ```js
     * if(body.linearLockAxis & LockAxis.Y) {
     *     console.log("The Y flag was set!");
     * }
     * ```
     *
     * @return axes that are currently locked for linear movement.
     */
    get linearLockAxis(): LockAxis;
    /**
     * Set axes to lock for angular velocity.
     *
     * @param lock The Axis that needs to be set.
     *
     * ```js
     * body.angularLockAxis = LockAxis.X | LockAxis.Y; // x and y set
     * body.angularLockAxis = LockAxis.X; // y unset
     * ```
     *
     * @note This has no effect if the component is static.
     */
    set angularLockAxis(lock: LockAxis);
    /**
     * Get the angular lock axes flags.
     *
     * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
     *
     * ```js
     * if(body.angularLockAxis & LockAxis.Y) {
     *     console.log("The Y flag was set!");
     * }
     * ```
     *
     * @return axes that are currently locked for angular movement.
     */
    get angularLockAxis(): LockAxis;
    /**
     * Set mass.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * @param m New mass.
     */
    set mass(m: number);
    /** Mass */
    get mass(): number;
    /**
     * Set mass space interia tensor.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New mass space interatia tensor.
     */
    set massSpaceInteriaTensor(v: Readonly<NumberArray>);
    /**
     * Apply a force.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     * @param localForce Whether the force vector is in local space, default `false`.
     * @param p Position to apply force at, default is center of mass.
     * @param local Whether position is in local space, default `false`.
     */
    addForce(f: Readonly<NumberArray>, m?: ForceMode, localForce?: boolean, p?: Readonly<NumberArray>, local?: boolean): void;
    /**
     * Apply torque.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     */
    addTorque(f: Readonly<NumberArray>, m?: ForceMode): void;
    /**
     * Add on collision callback.
     *
     * @param callback Function to call when this rigid body (un)collides with any other.
     *
     * ```js
     *  let rigidBody = this.object.getComponent('physx');
     *  rigidBody.onCollision(function(type, other) {
     *      // Ignore uncollides
     *      if(type == CollisionEventType.TouchLost) return;
     *
     *      // Take damage on collision with enemies
     *      if(other.object.name.startsWith('enemy-')) {
     *          this.applyDamage(10);
     *      }
     *  }.bind(this));
     * ```
     *
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollision(callback: CollisionCallback): number;
    /**
     * Add filtered on collision callback.
     *
     * @param otherComp Component for which callbacks will
     *        be triggered. If you pass this component, the method is equivalent to.
     *        {@link PhysXComponent#onCollision}.
     * @param callback Function to call when this rigid body
     *        (un)collides with `otherComp`.
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollisionWith(otherComp: this, callback: CollisionCallback): number;
    /**
     * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     *
     * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     * @throws When the callback does not belong to the component.
     * @throws When the callback does not exist.
     */
    removeCollisionCallback(callbackId: number): void;
}
/**
 * Access to the physics scene
 */
export declare class Physics {
    /**
     * @hidden
     *
     * **Note**: This is public to emulate a `friend` accessor.
     */
    _callbacks: Record<string, CollisionCallback[]>;
    /** Wonderland Engine instance */
    protected readonly _engine: WonderlandEngine;
    /** Ray Hit */
    private _rayHit;
    /** Hit. */
    private _hit;
    constructor(engine: WonderlandEngine);
    /**
     * Cast a ray through the physics scene and find intersecting objects.
     *
     * The resulting ray hit will contain **up to 4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     * @param maxDistance Maximum ray distance, default `100.0`.
     *
     * @returns The RayHit instance, belonging to this class.
     *
     * @note The returned {@link RayHit} object is owned by the Physics instance and
     *       will be reused with the next {@link Physics#rayCast} call.
     */
    rayCast(o: Readonly<NumberArray>, d: Readonly<NumberArray>, group: number, maxDistance?: number): RayHit;
}
/**
 * Mesh index type.
 */
export declare enum MeshIndexType {
    /** Single byte mesh index, range 0-255 */
    UnsignedByte = 1,
    /** Two byte mesh index, range 0-65535 */
    UnsignedShort = 2,
    /** Four byte mesh index, range 0-4294967295 */
    UnsignedInt = 4
}
/**
 * Mesh skinning type.
 */
export declare enum MeshSkinningType {
    /** Not skinned */
    None = 0,
    /** Skinned, 4 joints/weight per vertex */
    FourJoints = 1,
    /** Skinned, 8 joints/weight per vertex */
    EightJoints = 2
}
/**
 * Mesh constructor parameters object.
 *
 * Usage:
 *
 * ```js
 * const mesh = Mesh({vertexCount: 3, indexData: [0, 1, 2]});
 * ```
 */
export interface MeshParameters {
    /** Number of vertices to allocate. */
    vertexCount: number;
    /** Index data values. */
    indexData: Readonly<NumberArray>;
    /** Index type, `null` if not indexed. */
    indexType: MeshIndexType;
    /** Whether the mesh should be skinned. Defaults to not skinned. */
    skinningType: MeshSkinningType;
}
/**
 * Wrapper around a native mesh data.
 *
 * To modify a mesh, you get access to a {@link MeshAttributeAccessor} that allows you to modify
 * the content of the buffers:
 *
 * Usage:
 *
 * ```js
 * const mesh = new Mesh(engine, {vertexCount: 3, indexData: [0, 1, 2] });
 * const positions = mesh.attribute(MeshAttribute.Position);
 * ...
 * ```
 */
export declare class Mesh {
    /**
     * Index of the mesh in the manager.
     *
     * @hidden
     */
    readonly _index: number;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /**
     * Create a new instance.
     *
     * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
     *    For more information, please have a look at the {@link MeshParameters} interface.
     */
    constructor(engine: WonderlandEngine, params: Partial<MeshParameters> | number);
    /** Number of vertices in this mesh. */
    get vertexCount(): number;
    /** Index data (read-only) or `null` if the mesh is not indexed. */
    get indexData(): Uint8Array | Uint16Array | Uint32Array | null;
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * Apply changes to {@link attribute | vertex attributes}.
     *
     * Uploads the updated vertex attributes to the GPU and updates the bounding
     * sphere to match the new vertex positions.
     *
     * Since this is an expensive operation, call it only once you have performed
     * all modifications on a mesh and avoid calling if you did not perform any
     * modifications at all.
     */
    update(): void;
    /** @overload */
    getBoundingSphere(): Float32Array;
    /** @overload */
    getBoundingSphere<T extends NumberArray>(out: T): T;
    /**
     * Mesh bounding sphere.
     *
     * @param out Preallocated array to write into, to avoid garbage,
     *     otherwise will allocate a new Float32Array.
     *
     * ```js
     *  const sphere = new Float32Array(4);
     *  for(...) {
     *      mesh.getBoundingSphere(sphere);
     *      ...
     *  }
     * ```
     *
     * If the position data is changed, call {@link Mesh#update} to update the
     * bounding sphere.
     *
     * @returns Bounding sphere, 0-2 sphere origin, 3 radius.
     */
    getBoundingSphere<T extends NumberArray>(out: T | Float32Array): T | Float32Array;
    /** @overload */
    attribute(attr: MeshAttribute.Position): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.Tangent): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.Normal): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.TextureCoordinate): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.Color): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.JointId): MeshAttributeAccessor<Uint16ArrayConstructor> | null;
    /** @overload */
    attribute(attr: MeshAttribute.JointWeight): MeshAttributeAccessor<Float32ArrayConstructor> | null;
    /**
     * Get an attribute accessor to retrieve or modify data of give attribute.
     *
     * @param attr Attribute to get access to
     * @returns Attribute to get access to or `null`, if mesh does not have this attribute.
     *
     * Call {@link update} for changes to vertex attributes to take effect.
     *
     * If there are no shaders in the scene that use `TextureCoordinate` for example,
     * no meshes will have the `TextureCoordinate` attribute.
     *
     * For flexible reusable components, take this into account that only `Position`
     * is guaranteed to be present at all time.
     */
    attribute(attr: MeshAttribute): MeshAttributeAccessor | null;
    /**
     * Destroy and free the meshes memory.
     *
     * It is best practice to set the mesh variable to `null` after calling
     * destroy to prevent accidental use:
     *
     * ```js
     *   mesh.destroy();
     *   mesh = null;
     * ```
     *
     * Accessing the mesh after destruction behaves like accessing an empty
     * mesh.
     *
     * @since 0.9.0
     */
    destroy(): void;
    /**
     * Checks equality by comparing whether the wrapped native mesh ids are
     * equal.
     *
     * @param otherMesh Mesh to check equality with.
     * @returns Whether this mesh equals the given mesh.
     *
     * @since 1.0.0
     */
    equals(otherMesh: Mesh | undefined | null): boolean;
}
/**
 * Options to create a new {@link MeshAttributeAccessor} instance.
 */
interface MeshAttributeAccessorOptions<T extends TypedArrayCtor> {
    attribute: number;
    offset: number;
    stride: number;
    formatSize: number;
    componentCount: number;
    arraySize: number;
    length: number;
    bufferType: T;
}
/**
 * An iterator over a mesh vertex attribute.
 *
 * Usage:
 *
 * ```js
 *   const mesh = this.object.getComponent('mesh').mesh;
 *   const positions = mesh.attribute(WL.MeshAttribute.Position);
 *
 *   const temp = new Float32Array(3);
 *   for(int i = 0; i < positions.length; ++i) {
 *       // pos will reference temp and thereby not allocate additional
 *       // JavaScript garbage, which would cause a perf spike when collected.
 *       const pos = positions.get(i, temp);
 *       // scale position by 2 on X axis only
 *       pos[0] *= 2.0f;
 *       positions.set(i, pos);
 *   }
 *   // we're done modifying, tell the engine to move vertex data to the GPU
 *   mesh.update();
 * ```
 */
export declare class MeshAttributeAccessor<T extends TypedArrayCtor = TypedArrayCtor> {
    /** Max number of elements. */
    readonly length: number;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /** Attribute index. @hidden */
    private _attribute;
    /** Attribute offset. @hidden */
    private _offset;
    /** Attribute stride. @hidden */
    private _stride;
    /** Format size native enum. @hidden */
    private _formatSize;
    /** Number of components per vertex. @hidden */
    private _componentCount;
    /** Number of values per vertex. @hidden */
    private _arraySize;
    /**
     * Class to instantiate an ArrayBuffer to get/set values.
     */
    private _bufferType;
    /**
     * Function to allocate temporary WASM memory. It is cached in the accessor to avoid
     * conditionals during get/set.
     */
    private _tempBufferGetter;
    /**
     * Create a new instance.
     *
     * @note Please use {@link Mesh.attribute} to create a new instance.
     *
     * @param options Contains information about how to read the data.
     * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
     *
     * @hidden
     */
    constructor(engine: WonderlandEngine, options: MeshAttributeAccessorOptions<T>);
    /**
     * Create a new TypedArray to hold this attribute's values.
     *
     * This method is useful to create a view to hold the data to
     * pass to {@link get} and {@link set}
     *
     * Example:
     *
     * ```js
     * const vertexCount = 4;
     * const positionAttribute = mesh.attribute(MeshAttributes.Position);
     *
     * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
     * const positions = positionAttribute.createArray(vertexCount);
     * ```
     *
     * @param count The number of **vertices** expected.
     * @returns A TypedArray with the appropriate format to access the data
     */
    createArray(count?: number): TypedArray<T>;
    /** @overload */
    get(index: number): TypedArray<T>;
    /**
     * Get attribute element.
     *
     * @param index Index
     * @param out Preallocated array to write into,
     *      to avoid garbage, otherwise will allocate a new TypedArray.
     *
     * `out.length` needs to be a multiple of the attributes component count, see
     * {@link MeshAttribute}. If `out.length` is more than one multiple, it will be
     * filled with the next n attribute elements, which can reduce overhead
     * of this call.
     *
     * @returns The `out` parameter
     */
    get<T extends NumberArray>(index: number, out: T): T;
    /**
     * Set attribute element.
     *
     * @param i Index
     * @param v Value to set the element to
     *
     * `v.length` needs to be a multiple of the attributes component count, see
     * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
     * filled with the next n attribute elements, which can reduce overhead
     * of this call.
     *
     * @returns Reference to self (for method chaining)
     */
    set(i: number, v: Readonly<NumberArray>): this;
}
/**
 * Constructor parameters object for a {@link Material} instance.
 */
export interface MaterialParameters {
    /** The name of the pipeline. */
    pipeline: string;
}
/**
 * Wrapper around a native material.
 *
 * Each material instance will have properties associated to the pipeline it uses.
 * The material properties are automatically added to each material instance, example:
 *
 * ```js
 * const material = mesh.material; // Material with a `Phong Opaque Textured` pipeline
 * // You can access all the material properties from the editor using:
 * material.diffuseTexture = null;
 * material.diffuseColor = [1.0, 0.0, 0.0, 1.0];
 * ```
 */
export declare class Material {
    /**
     * Index of this material in the manager.
     *
     * @hidden
     */
    _index: number;
    /**
     * Material definition index in the scene.
     *
     * @hidden
     */
    private _definition;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /**
     * Create a new Material.
     *
     * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
     * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
     */
    constructor(engine: WonderlandEngine, params: number | MaterialParameters);
    /** @deprecated Use {@link #pipeline} instead. */
    get shader(): string;
    /** Name of the pipeline used by this material. */
    get pipeline(): string;
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * Create a copy of the underlying native material.
     *
     * @returns Material clone.
     */
    clone(): Material | null;
    /**
     * Checks equality by comparing whether the wrapped native material ids are
     * equal.
     *
     * @param otherMaterial Material to check equality with.
     * @returns Whether this material equals the given material.
     *
     * @since 1.0.0
     */
    equals(otherMaterial: Material | undefined | null): boolean;
    /**
     * Wrap a native material index.
     *
     * @param engine Engine instance.
     * @param index The index.
     * @returns Material instance or `null` if index <= 0.
     *
     * @deprecated Please use `new Material()` instead.
     */
    static wrap(engine: WonderlandEngine, index: number): Material | null;
}
/**
 * Wrapper around a native texture data.
 */
export declare class Texture {
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /** Index in the manager. @hidden */
    private _id;
    /** HTML image index. @hidden */
    private _imageIndex;
    /**
     * @param engine The engine instance
     * @param param HTML media element to create texture from or texture id to wrap.
     */
    constructor(engine: WonderlandEngine, param: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | number);
    /** Whether this texture is valid. */
    get valid(): boolean;
    /** Index in this manager. */
    get id(): number;
    /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
    update(): void;
    /** Width of the texture. */
    get width(): number;
    /** Height of the texture. */
    get height(): number;
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
     *
     * Usage:
     *
     * ```js
     * // Copies rectangle of pixel starting from (10, 20)
     * texture.updateSubImage(10, 20, 600, 400);
     * ```
     *
     * @param x x offset
     * @param y y offset
     * @param w width
     * @param h height
     */
    updateSubImage(x: number, y: number, w: number, h: number): void;
    /**
     * Destroy and free the texture's texture altas space and memory.
     *
     * It is best practice to set the texture variable to `null` after calling
     * destroy to prevent accidental use of the invalid texture:
     *
     * ```js
     *   texture.destroy();
     *   texture = null;
     * ```
     *
     * @since 0.9.0
     */
    destroy(): void;
    /**
     * Checks equality by comparing whether the wrapped native texture ids are
     * equal.
     *
     * @param otherTexture Texture to check equality with.
     * @returns Whether this texture equals the given texture.
     *
     * @since 1.0.0
     */
    equals(otherTexture: Texture | undefined | null): boolean;
}
/**
 * Wrapper around a native animation.
 */
export declare class Animation {
    /** Index of the mesh in the manager. @hidden */
    _index: number;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /**
     * @param index Index in the manager
     */
    constructor(engine: WonderlandEngine | undefined, index: number);
    /** Duration of this animation. */
    get duration(): number;
    /** Number of tracks in this animation. */
    get trackCount(): number;
    /**
     * Clone this animation retargeted to a new set of objects.
     *
     * The clone shares most of the data with the original and is therefore
     * light-weight.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * If retargeting to {@link Skin}, the join names will be used to determine a mapping
     * from the previous skin to the new skin. The source skin will be retrieved from
     * the first track in the animation that targets a joint.
     *
     * @param newTargets New targets per track. Expected to have
     *      {@link Animation#trackCount} elements or to be a {@link Skin}.
     * @returns The retargeted clone of this animation.
     */
    retarget(newTargets: Object3D[] | Skin): Animation;
    /**
     * Checks equality by comparing whether the wrapped native animation ids
     * are equal.
     *
     * @param otherAnimation Animation to check equality with.
     * @returns Whether this animation equals the given animation.
     *
     * @since 1.0.0
     */
    equals(otherAnimation: Animation | undefined | null): boolean;
}
/**
 * Scene graph object.
 *
 * Node in the scene graph or "entity". Consists of transformation and a reference
 * to its parent object. Usually holds components and is accessible by components
 * through {@link Component#object}.
 *
 * Objects are stored in a data oriented manner inside WebAssembly memory. This class
 * is a JavaScript API wrapper around this memory for more convenient use in
 * components.
 *
 * Objects can be created and added to a scene through
 * {@link Scene#addObject} on the {@link WonderlandEngine.scene}.
 */
export declare class Object3D {
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /**
     * Object index in the manager.
     *
     * @hidden
     */
    protected readonly _objectId: number;
    /**
     * @param o Object id to wrap
     *
     * For performance reasons, please use {@link WonderlandEngine.wrapObject}
     */
    constructor(engine: WonderlandEngine, o: number);
    /**
     * Name of the object.
     *
     * Useful for identifying objects during debugging.
     */
    get name(): string;
    /**
     * Set the object's name.
     *
     * @param newName The new name to set.
     */
    set name(newName: string);
    /**
     * Parent of this object or `null` if parented to root.
     */
    get parent(): Object3D | null;
    /**
     * Children of this object.
     */
    get children(): Object3D[];
    /**
     * Reparent object to given object.
     *
     * @note Reparenting is not trivial and might have a noticeable performance impact.
     *
     * @param newParent New parent or `null` to parent to root
     */
    set parent(newParent: Object3D | undefined | null);
    /** Object index in the manager. */
    get objectId(): number;
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * Reset local transformation (translation, rotation and scaling) to identity.
     *
     * @returns Reference to self (for method chaining).
     */
    resetTransform(): this;
    /**
     * Reset local position and rotation to identity.
     *
     * @returns Reference to self (for method chaining).
     */
    resetPositionRotation(): this;
    /** @deprecated Please use {@link Object3D.resetPositionRotation} instead. */
    resetTranslationRotation(): this;
    /**
     * Reset local rotation, keep translation.
     *
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     *
     * @returns Reference to self (for method chaining).
     */
    resetRotation(): this;
    /**
     * Reset local translation, keep rotation.
     *
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     *
     * @returns Reference to self (for method chaining).
     */
    resetPosition(): this;
    /** @deprecated Please use {@link Object3D.resetPosition} instead. */
    resetTranslation(): this;
    /**
     * Reset local scaling to identity (``[1.0, 1.0, 1.0]``).
     *
     * @returns Reference to self (for method chaining).
     */
    resetScaling(): this;
    /** @deprecated Please use {@link Object3D.translateLocal} instead. */
    translate(v: Readonly<NumberArray>): this;
    /**
     * Translate object by a vector in the parent's space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateLocal(v: Readonly<NumberArray>): this;
    /**
     * Translate object by a vector in object space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateObject(v: Readonly<NumberArray>): this;
    /**
     * Translate object by a vector in world space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateWorld(v: Readonly<NumberArray>): this;
    /** @deprecated Please use {@link Object3D.rotateAxisAngleDegLocal} instead. */
    rotateAxisAngleDeg(a: Readonly<NumberArray>, d: number): this;
    /**
     * Rotate around given axis by given angle (degrees) in local space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleRad}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleDegLocal(a: Readonly<NumberArray>, d: number): this;
    /** @deprecated Please use {@link Object3D.rotateAxisAngleRadLocal} instead. */
    rotateAxisAngleRad(a: Readonly<NumberArray>, d: number): this;
    /**
     * Rotate around given axis by given angle (radians) in local space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in radians.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleDeg}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleRadLocal(a: Readonly<NumberArray>, d: number): this;
    /**
     * Rotate around given axis by given angle (degrees) in object space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @see {@link rotateAxisAngleRadObject}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleDegObject(a: Readonly<NumberArray>, d: number): this;
    /**
     * Rotate around given axis by given angle (radians) in object space
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param a Vector representing the rotation axis
     * @param d Angle in degrees
     *
     * @see {@link rotateAxisAngleDegObject}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleRadObject(a: Readonly<NumberArray>, d: number): this;
    /** @deprecated Please use {@link Object3D.rotateLocal} instead. */
    rotate(q: Readonly<NumberArray>): this;
    /**
     * Rotate by a quaternion.
     *
     * @param q the Quaternion to rotate by.
     *
     * @returns Reference to self (for method chaining).
     */
    rotateLocal(q: Readonly<NumberArray>): this;
    /**
     * Rotate by a quaternion in object space.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param q the Quaternion to rotate by.
     *
     * @returns Reference to self (for method chaining).
     */
    rotateObject(q: Readonly<NumberArray>): this;
    /** @deprecated Please use {@link Object3D.scaleLocal} instead. */
    scale(v: Readonly<NumberArray>): this;
    /**
     * Scale object by a vector in object space.
     *
     * @param v Vector to scale by.
     *
     * @returns Reference to self (for method chaining).
     */
    scaleLocal(v: Readonly<NumberArray>): this;
    /** @overload */
    getPositionLocal(): Float32Array;
    /**
     * Compute local / object space position from transformation.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @returns The `out` parameter.
     */
    getPositionLocal<T extends NumberArray>(out: T): T;
    /** @overload */
    getTranslationLocal(): Float32Array;
    /** @deprecated Please use {@link Object3D.getPositionLocal} instead. */
    getTranslationLocal<T extends NumberArray>(out: T): T;
    /** @overload */
    getPositionWorld(): Float32Array;
    /**
     * Compute world space position from transformation.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getPositionWorld<T extends NumberArray>(out: T): T;
    /** @overload */
    getTranslationWorld(): Float32Array;
    /** @deprecated Please use {@link Object3D.getPositionWorld} instead. */
    getTranslationWorld<T extends NumberArray>(out: T): T;
    /**
     * Set local / object space position.
     *
     * Concatenates a new translation dual quaternion onto the existing rotation.
     *
     * @param v New local position array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setPositionLocal(v: Readonly<NumberArray>): this;
    /** @deprecated Please use {@link Object3D.setPositionLocal} instead. */
    setTranslationLocal(v: Readonly<NumberArray>): this;
    /**
     * Set world space position.
     *
     * Applies the inverse parent transform with a new translation dual quaternion
     * which is concatenated onto the existing rotation.
     *
     * @param v New world position array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setPositionWorld(v: Readonly<NumberArray>): this;
    /** @deprecated Please use {@link Object3D.setPositionWorld} instead. */
    setTranslationWorld(v: Readonly<NumberArray>): this;
    /** @overload */
    getScalingLocal(): Float32Array;
    /**
     * Local / object space scaling.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     *
     * @since 1.0.0
     */
    getScalingLocal<T extends NumberArray>(out: T): T;
    /**
     * Set local / object space scaling.
     *
     * @param v New local scaling array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setScalingLocal(v: Readonly<NumberArray>): this;
    /** @overload */
    getScalingWorld(): Float32Array;
    /**
     * World space scaling.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     *
     * @since 1.0.0
     */
    getScalingWorld<T extends NumberArray>(out: T): T;
    /**
     * Set World space scaling.
     *
     * @param v New world scaling array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setScalingWorld(v: Readonly<NumberArray>): this;
    /** @overload */
    getRotationLocal(): Float32Array;
    /**
     * Local space rotation.
     *
     * @param out Destination array/vector, expected to have at least 4 elements.
     * @return The `out` parameter.
     *
     * @since 1.0.0
     */
    getRotationLocal<T extends NumberArray>(out: T): T;
    /**
     * Set local space rotation.
     *
     * @param v New world rotation array/vector, expected to have at least 4 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setRotationLocal(v: Readonly<NumberArray>): this;
    /** @overload */
    getRotationWorld(): Float32Array;
    /**
     * World space rotation.
     *
     * @param out Destination array/vector, expected to have at least 4 elements.
     * @return The `out` parameter.
     *
     * @since 1.0.0
     */
    getRotationWorld<T extends NumberArray>(out: T): T;
    /**
     * Set local space rotation.
     *
     * @param v New world rotation array/vector, expected to have at least 4 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setRotationWorld(v: Readonly<NumberArray>): this;
    /** @overload */
    getTransformLocal(): Float32Array;
    /**
     * Local space transformation.
     *
     * @param out Destination array/vector, expected to have at least 8 elements.
     * @return The `out` parameter.
     */
    getTransformLocal<T extends NumberArray>(out: T): T;
    /**
     * Set local space rotation.
     *
     * @param v New local transform array, expected to have at least 8 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setTransformLocal(v: Readonly<NumberArray>): this;
    /** @overload */
    getTransformWorld(): Float32Array;
    /**
     * World space transformation.
     *
     * @param out Destination array, expected to have at least 8 elements.
     * @return The `out` parameter.
     */
    getTransformWorld<T extends NumberArray>(out: T): T;
    /**
     * Set world space rotation.
     *
     * @param v New world transform array, expected to have at least 8 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setTransformWorld(v: Readonly<NumberArray>): this;
    /**
     * Local space transformation.
     *
     * @deprecated Please use {@link Object3D.setTransformLocal} and
     * {@link Object3D.getTransformLocal} instead.
     */
    get transformLocal(): Float32Array;
    /**
     * Set local transform.
     *
     * @param t Local space transformation.
     *
     * @since 0.8.5
     *
     * @deprecated Please use {@link Object3D.setTransformLocal} and
     * {@link Object3D.getTransformLocal} instead.
     */
    set transformLocal(t: Readonly<NumberArray>);
    /**
     * Global / world space transformation.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @deprecated Please use {@link Object3D.setTransformWorld} and
     * {@link Object3D.getTransformWorld} instead.
     */
    get transformWorld(): Float32Array;
    /**
     * Set world transform.
     *
     * @param t Global / world space transformation.
     *
     * @since 0.8.5
     *
     * @deprecated Please use {@link Object3D.setTransformWorld} and
     * {@link Object3D.getTransformWorld} instead.
     */
    set transformWorld(t: Readonly<NumberArray>);
    /**
     * Local / object space scaling.
     *
     * @deprecated Please use {@link Object3D.setScalingLocal} and
     * {@link Object3D.getScalingLocal} instead.
     */
    get scalingLocal(): Float32Array;
    /**
     * Set local space scaling.
     *
     * @param s Local space scaling.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.setScalingLocal} and
     * {@link Object3D.getScalingLocal} instead.
     */
    set scalingLocal(s: Readonly<NumberArray>);
    /**
     * Global / world space scaling.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @deprecated Please use {@link Object3D.setScalingWorld} and
     * {@link Object3D.getScalingWorld} instead.
     */
    get scalingWorld(): Float32Array;
    /**
     * Set world space scaling.
     *
     * @param t World space scaling.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.setScalingWorld} and
     * {@link Object3D.getScalingWorld} instead.
     */
    set scalingWorld(s: Readonly<NumberArray>);
    /**
     * Local space rotation.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationLocal} and
     * {@link Object3D.setRotationLocal} instead.
     */
    get rotationLocal(): Float32Array;
    /**
     * Global / world space rotation
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationWorld} and
     * {@link Object3D.setRotationWorld} instead.
     */
    get rotationWorld(): Float32Array;
    /**
     * Set local space rotation.
     *
     * @param r Local space rotation
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationLocal} and
     * {@link Object3D.setRotationLocal} instead.
     */
    set rotationLocal(r: Readonly<NumberArray>);
    /**
     * Set world space rotation.
     *
     * @param r Global / world space rotation.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationWorld} and
     * {@link Object3D.setRotationWorld} instead.
     */
    set rotationWorld(r: Readonly<NumberArray>);
    /** @deprecated Please use {@link Object3D.getForwardWorld} instead. */
    getForward<T extends NumberArray>(out: T): T;
    /**
     * Compute the object's forward facing world space vector.
     *
     * The forward vector in object space is along the negative z-axis, i.e.,
     * `[0, 0, -1]`.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getForwardWorld<T extends NumberArray>(out: T): T;
    /** @deprecated Please use {@link Object3D.getUpWorld} instead. */
    getUp<T extends NumberArray>(out: T): T;
    /**
     * Compute the object's up facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getUpWorld<T extends NumberArray>(out: T): T;
    /** @deprecated Please use {@link Object3D.getRightWorld} instead. */
    getRight<T extends NumberArray>(out: T): T;
    /**
     * Compute the object's right facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getRightWorld<T extends NumberArray>(out: T): T;
    /**
     * Transform a vector by this object's world transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorWorld<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a vector by this object's local transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorLocal<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a point by this object's world transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointWorld<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a point by this object's local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointLocal<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a vector by this object's inverse world transform.
     *
     * @param out Out vector.
     * @param v Vector to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseWorld<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a vector by this object's inverse local transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseLocal<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a point by this object's inverse world transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseWorld<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a point by this object's inverse local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseLocal<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform an object space dual quaternion into world space.
     *
     * @param out Out transformation.
     * @param q Local space transformation, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toWorldSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Transform a world space dual quaternion into local space.
     *
     * @param out Out transformation
     * @param q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toLocalSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Transform a world space dual quaternion into object space.
     *
     * @param out Out transformation.
     * @param q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toObjectSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Turn towards / look at target.
     *
     * Rotates the object so that its forward vector faces towards the target
     * position. The `up` vector acts as a hint to uniquely orient the object's
     * up direction. When orienting a view component, the projected `up` vector
     * faces upwards on the viewing plane.
     *
     * @param p Target position to turn towards, in world space.
     * @param up Up vector to align object with, in world space. Default is `[0, 1, 0]`.
     *
     * @returns Reference to self (for method chaining).
     */
    lookAt(p: NumberArray, up?: NumberArray): this;
    /** Destroy the object with all of its components and remove it from the scene */
    destroy(): void;
    /**
     * Mark transformation dirty.
     *
     * Causes an eventual recalculation of {@link transformWorld}, either
     * on next {@link getTranslationWorld}, {@link transformWorld} or
     * {@link scalingWorld} or the beginning of next frame, whichever
     * happens first.
     */
    setDirty(): void;
    /**
     * Disable/enable all components of this object.
     *
     * @param b New state for the components.
     *
     * @since 0.8.5
     */
    set active(b: boolean);
    /** @overload */
    getComponent(type: 'collision', index?: number): CollisionComponent | null;
    /** @overload */
    getComponent(type: 'text', index?: number): TextComponent | null;
    /** @overload */
    getComponent(type: 'view', index?: number): ViewComponent | null;
    /** @overload */
    getComponent(type: 'mesh', index?: number): MeshComponent | null;
    /** @overload */
    getComponent(type: 'input', index?: number): InputComponent | null;
    /** @overload */
    getComponent(type: 'light', index?: number): LightComponent | null;
    /** @overload */
    getComponent(type: 'animation', index?: number): AnimationComponent | null;
    /** @overload */
    getComponent(type: 'physx', index?: number): PhysXComponent | null;
    /** @overload */
    getComponent(typeOrClass: string, index?: number): Component | null;
    /**
     * Get a component attached to this object.
     *
     * @param typeOrClass Type name. It's also possible to give a class definition.
     *     In this case, the method will use the `class.TypeName` field to find the component.
     * @param index=0 Index for component of given type. This can be used to access specific
     *      components if the object has multiple components of the same type.
     * @returns The component or `null` if there is no such component on this object
     */
    getComponent<T extends Component>(typeOrClass: ComponentConstructor<T>, index?: number): T | null;
    /**
     * @param typeOrClass Type name, pass a falsey value (`undefined` or `null`) to retrieve all.
     *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to
     *     find the components.
     * @returns All components of given type attached to this object.
     *
     * @note As this function is non-trivial, avoid using it in `update()` repeatedly,
     *      but rather store its result in `init()` or `start()`
     * @warning This method will currently return at most 341 components.
     */
    getComponents<T extends Component>(typeOrClass?: string | ComponentConstructor<T> | null): T[];
    /** @overload */
    addComponent(type: 'collision', params?: Record<string, any>): CollisionComponent | null;
    /** @overload */
    addComponent(type: 'text', params?: Record<string, any>): TextComponent | null;
    /** @overload */
    addComponent(type: 'view', params?: Record<string, any>): ViewComponent | null;
    /** @overload */
    addComponent(type: 'mesh', params?: Record<string, any>): MeshComponent | null;
    /** @overload */
    addComponent(type: 'input', params?: Record<string, any>): InputComponent | null;
    /** @overload */
    addComponent(type: 'light', params?: Record<string, any>): LightComponent | null;
    /** @overload */
    addComponent(type: 'animation', params?: Record<string, any>): AnimationComponent | null;
    /** @overload */
    addComponent(type: 'physx', params?: Record<string, any>): PhysXComponent | null;
    /** @overload */
    addComponent(type: string, params?: Record<string, any>): Component | null;
    /**
     * Add component of given type to the object.
     *
     * You can use this function to clone components, see the example below.
     *
     * ```js
     *  // Clone existing component (since 0.8.10)
     *  let original = this.object.getComponent('mesh');
     *  otherObject.addComponent('mesh', original);
     *  // Create component from parameters
     *  this.object.addComponent('mesh', {
     *      mesh: someMesh,
     *      material: someMaterial,
     *  });
     * ```
     *
     * @param typeOrClass Typename to create a component of. Can be native or
     *     custom JavaScript component type. It's also possible to give a class definition.
     *     In this case, the method will use the `class.TypeName` field.
     * @param params Parameters to initialize properties of the new component,
     *      can be another component to copy properties from.
     *
     * @returns The component or `null` if the type was not found
     */
    addComponent<T extends Component>(typeClass: ComponentConstructor<T>, params?: Record<string, any>): T | null;
    /**
     * Whether given object's transformation has changed.
     */
    get changed(): boolean;
    /**
     * Checks equality by comparing whether the wrapped native object ids are
     * equal.
     *
     * @param otherObject Object to check equality with.
     * @returns Whether this object equals the given object.
     */
    equals(otherObject: Object3D | undefined | null): boolean;
}
/**
 * Wrapper around a native skin data.
 */
export declare class Skin {
    /**
     * Index of the skin in the manager.
     * @hidden
     */
    _index: number;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    constructor(engine: WonderlandEngine, index: number);
    /** Amount of joints in this skin. */
    get jointCount(): number;
    /** Joints object ids for this skin */
    get jointIds(): Uint16Array;
    /**
     * Dual quaternions in a flat array of size 8 times {@link jointCount}.
     *
     * Inverse bind transforms of the skin.
     */
    get inverseBindTransforms(): Float32Array;
    /**
     * Vectors in a flat array of size 3 times {@link jointCount}.
     *
     * Inverse bind scalings of the skin.
     */
    get inverseBindScalings(): Float32Array;
    /**
     * Checks equality by comparing whether the wrapped native skin ids are
     * equal.
     *
     * @param otherSkin Skin to check equality with.
     * @returns Whether this skin equals the given skin.
     *
     * @since 1.0.0
     */
    equals(otherSkin: Skin | undefined | null): boolean;
}
export { Object3D as Object };
/**
 * Ray hit.
 *
 * Result of a {@link Scene.rayCast}.
 *
 * @note this class wraps internal engine data and should only be created internally.
 */
export declare class RayHit {
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /** Pointer to the memory heap. */
    private _ptr;
    /**
     * @param ptr Pointer to the ray hits memory.
     */
    constructor(engine: WonderlandEngine, ptr: number);
    /** Array of ray hit locations. */
    get locations(): Float32Array[];
    /** Array of ray hit normals (only when using {@link Physics#rayCast}. */
    get normals(): Float32Array[];
    /**
     * Prefer these to recalculating the distance from locations.
     *
     * Distances of array hits to ray origin.
     */
    get distances(): Float32Array;
    /** Hit objects */
    get objects(): (Object3D | null)[];
    /** Number of hits (max 4) */
    get hitCount(): number;
}
declare class math {
    /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.
     *
     * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.
     *
     * Whether a quaternion or vector3 interpolation is intended is determined by
     * length of `a`.
     *
     * @param out Array to write result to.
     * @param a First tangent/handle.
     * @param b First point or quaternion.
     * @param c Second point or quaternion.
     * @param d Second handle.
     * @param f Interpolation factor in [0; 1].
     * @returns The `out` parameter.
     *
     * @since 0.8.6
     */
    static cubicHermite<T extends NumberArray>(out: T, a: Readonly<NumberArray>, b: Readonly<NumberArray>, c: Readonly<NumberArray>, d: Readonly<NumberArray>, f: number, engine?: WonderlandEngine): T;
}
export { math };
/**
 * Class for accessing internationalization (i18n) features.
 *
 * Allows {@link I18N.onLanguageChanged "detecting language change"},
 * {@link I18N.language "setting the current language"} or translating
 * {@link I18N.translate() "individual terms"}.
 *
 * Internationalization works with terms,
 * a string type keyword that is linked to a different text for each language.
 *
 * Internally, string parameters for text and js components are
 * automatically swapped during language change, given they are linked to a term.
 * If manual text swapping is desired, {@link I18N.translate()}
 * can be used to retrieve the current translation for any term.
 *
 * You can also use the {@link I18N.onLanguageChanged} to manually update text
 * when a language is changed to for example update a number in a string.
 *
 * @since 1.0.0
 */
export declare class I18N {
    /**
     * {@link Emitter} for language change events.
     *
     * First parameter to a listener is the old language index,
     * second parameter is the new language index.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.i18n.onLanguageChanged.add((oldLanguageIndex, newLanguageIndex) => {
     *     const oldLanguage = this.engine.i18n.languageName(oldLanguageIndex);
     *     const newLanguage = this.engine.i18n.languageName(newLanguageIndex);
     *     console.log("Switched from", oldLanguage, "to", newLanguage);
     * });
     * ```
     */
    readonly onLanguageChanged: Emitter<[number, number]>;
    /** Wonderland Engine instance. @hidden */
    protected _engine: WonderlandEngine;
    /**
     * Constructor
     */
    constructor(engine: WonderlandEngine);
    /**
     * Set current language and apply translations to linked text parameters.
     *
     * @param code Language code to switch to
     */
    set language(code: string | null);
    /**
     * Get current language code.
     *
     */
    get language(): string | null;
    /**
     * Get translated string for a term for the currently loaded language.
     *
     * @param term Term to translate
     */
    translate(term: string): string | null;
    /**
     * Get the number of languages in the project.
     *
     */
    languageCount(): number;
    /**
     * Get a language code.
     *
     * @param index Index of the language to get the code from
     */
    languageIndex(code: string): number;
    /**
     * Get a language code.
     *
     * @param index Index of the language to get the code from
     */
    languageCode(index: number): string | null;
    /**
     * Get a language name.
     *
     * @param index Index of the language to get the name from
     */
    languageName(index: number): string | null;
}
/** Properties of a WebXR session */
export declare class XR {
    #private;
    constructor(wasm: any, mode: XRSessionMode);
    /** Current WebXR session mode */
    get sessionMode(): XRSessionMode;
    /** Current WebXR session */
    get session(): XRSession;
    /** Current WebXR frame */
    get frame(): XRFrame;
    /** @overload */
    referenceSpaceForType(type: 'viewer'): XRReferenceSpace;
    /**
     * Get a WebXR reference space of a given reference space type.
     *
     * @param type Type of reference space to get
     * @returns Reference space, or `null` if there's no reference space
     *     of the requested type available
     */
    referenceSpaceForType(type: XRReferenceSpaceType): XRReferenceSpace | null;
    /** Set current reference space type used for retrieving eye, head, hand and joint poses */
    set currentReferenceSpace(refSpace: XRReferenceSpace);
    /** Current reference space type used for retrieving eye, head, hand and joint poses */
    get currentReferenceSpace(): XRReferenceSpace;
    /** Current WebXR reference space type or `null` if not a default reference space */
    get currentReferenceSpaceType(): XRReferenceSpaceType;
    /** Current WebXR base layer  */
    get baseLayer(): XRProjectionLayer;
    /** Current WebXR framebuffer */
    get framebuffers(): WebGLFramebuffer[];
}
