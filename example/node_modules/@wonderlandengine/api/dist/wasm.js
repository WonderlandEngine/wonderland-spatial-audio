import { RetainEmitter } from './index.js';
import { Type } from './property.js';
import { Animation, Component, Material, Mesh, Skin, XR, } from './wonderland.js';
/**
 * Default component parameter value per type.
 */
const _componentDefaults = new Map([
    [Type.Bool, false],
    [Type.Int, 0],
    [Type.Float, 0.0],
    [Type.String, ''],
    [Type.Enum, undefined],
    [Type.Object, null],
    [Type.Mesh, null],
    [Type.Texture, null],
    [Type.Material, null],
    [Type.Animation, null],
    [Type.Skin, null],
    [Type.Color, [0.0, 0.0, 0.0, 1.0]],
]);
/**
 * Setup the defaults value of the properties on a given
 * component class.
 *
 * @param ctor The component class
 */
function _setupDefaults(ctor) {
    for (const name in ctor.Properties) {
        const p = ctor.Properties[name];
        if (p.type === Type.Enum) {
            /* Enum default can be a string or an index. Convert to and/or
             * sanity-check the index. */
            if (p.values?.length) {
                /* Don't try to look up the default if the user specified a
                 * number or we already converted to one. */
                if (typeof p.default !== 'number') {
                    /* If undefined, missing element or wrong type this returns
                     * -1 which becomes 0 below. This matches editor behavior. */
                    p.default = p.values.indexOf(p.default);
                }
                if (p.default < 0 || p.default >= p.values.length) {
                    p.default = 0;
                }
            }
            else {
                /* There's no index value that makes sense */
                p.default = undefined;
            }
        }
        else {
            p.default = p.default ?? _componentDefaults.get(p.type);
        }
        ctor.prototype[name] = p.default;
    }
}
/**
 * Low-level wrapper to interact with the WebAssembly code.
 *
 * @hidden
 */
export class WASM {
    /**
     * Emscripten worker field.
     *
     * @note This api is meant to be used internally.
     */
    worker = '';
    /**
     * Emscripten wasm field.
     *
     * @note This api is meant to be used internally.
     */
    wasm = null;
    /**
     * Emscripten canvas.
     *
     * @note This api is meant to be used internally.
     */
    canvas = null;
    /** Current WebXR  */
    /**
     * Emscripten WebXR session.
     *
     * @note This api is meant to be used internally.
     */
    webxr_session = null;
    /**
     * Emscripten WebXR request session callback.
     *
     * @note This api is meant to be used internally.
     */
    webxr_requestSession = null;
    /**
     * Emscripten WebXR frame.
     *
     * @note This api is meant to be used internally.
     */
    webxr_frame = null;
    /**
     * Emscripten current WebXR reference space.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpace = null;
    /**
     * Emscripten WebXR reference spaces.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaces = null;
    /**
     * Emscripten WebXR current reference space type.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaceType = null;
    /**
     * Emscripten WebXR GL projection layer.
     *
     * @note This api is meant to be used internally.
     */
    webxr_baseLayer = null;
    /**
     * Emscripten WebXR framebuffer scale factor.
     *
     * @note This api is meant to be used internally.
     */
    webxr_framebufferScaleFactor = 1.0;
    /**
     * Emscripten WebXR framebuffer(s).
     *
     * @note This api is meant to be used internally.
     */
    /* webxr_fbo will not get overwritten if we are rendering to the
     * default framebuffer, e.g., when using WebXR emulator. */
    webxr_fbo = 0;
    /**
     * Convert a WASM memory view to a JavaScript string.
     *
     * @param ptr Pointer start
     * @param ptrEnd Pointer end
     * @returns JavaScript string
     */
    UTF8ViewToString;
    /** If `true`, logs will not spam the console on error. */
    _deactivate_component_on_error = false;
    /** Temporary memory pointer. */
    _tempMem = null;
    /** Temporary memory size. */
    _tempMemSize = 0;
    /** Temporary float memory view. */
    _tempMemFloat = null;
    /** Temporary int memory view. */
    _tempMemInt = null;
    /** Temporary uint8 memory view. */
    _tempMemUint8 = null;
    /** Temporary uint32 memory view. */
    _tempMemUint32 = null;
    /** Temporary uint16 memory view. */
    _tempMemUint16 = null;
    /** Loading screen .bin file data */
    _loadingScreen = null;
    /** List of callbacks triggered when the scene is loaded. */
    _sceneLoadedCallback = [];
    /**
     * Material definition cache. Each pipeline has its own
     * associated material definition.
     */
    _materialDefinitions = [];
    /** Image cache. */
    _images = [];
    /** Component instances. */
    _components = [];
    /** Component Type info. */
    _componentTypes = [];
    /** Index per component type name. */
    _componentTypeIndices = {};
    /** Wonderland engine instance. */
    _engine = null;
    /**
     * `true` if this runtime is using physx.
     *
     * @note This api is meant to be used internally.
     */
    _withPhysX = false;
    /** Decoder for UTF8 `ArrayBuffer` to JavaScript string. */
    _utf8Decoder = new TextDecoder('utf8');
    /** List of .bin files to delay-load. */
    _queuedBinFiles = [];
    /**
     * Create a new instance of the WebAssembly <> API bridge.
     *
     * @param threads `true` if the runtime used has threads support
     */
    constructor(threads) {
        if (threads) {
            this.UTF8ViewToString = (s, e) => {
                if (!s)
                    return '';
                return this._utf8Decoder.decode(this.HEAPU8.slice(s, e));
            };
            return;
        }
        this.UTF8ViewToString = (s, e) => {
            if (!s)
                return '';
            return this._utf8Decoder.decode(this.HEAPU8.subarray(s, e));
        };
    }
    /**
     * Reset the cache of the library
     *
     * @note Should only be called when tearing down the runtime.
     */
    reset() {
        this._materialDefinitions = [];
        this._images = [];
        this._components = [];
        this._componentTypes = [];
        this._componentTypeIndices = {};
    }
    /**
     * Checks whether the given component is registered or not.
     *
     * @param ctor  A string representing the component typename (e.g., `'cursor-component'`).
     * @returns `true` if the component is registered, `false` otherwise.
     */
    isRegistered(type) {
        return type in this._componentTypeIndices;
    }
    /**
     * Register a legacy component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param typeName The name of the component.
     * @param params An object containing the parameters (properties).
     * @param object The object's prototype.
     * @returns The registration index
     */
    _registerComponentLegacy(typeName, params, object) {
        const ctor = class CustomComponent extends Component {
        };
        ctor.TypeName = typeName;
        ctor.Properties = params;
        Object.assign(ctor.prototype, object);
        return this._registerComponent(ctor);
    }
    /**
     * Register a class component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param ctor The class to register.
     * @returns The registration index.
     */
    _registerComponent(ctor) {
        if (!ctor.TypeName)
            throw new Error('no name provided for component.');
        // TODO: 'Dependencies' is hard-deprecated, remove at 1.1
        const dependencies = ctor.Dependencies;
        if (dependencies) {
            for (const dependency of dependencies) {
                /* For dependencies, we skip potential over-registration. */
                if (!this.isRegistered(dependency.TypeName)) {
                    this._registerComponent(dependency);
                }
            }
        }
        _setupDefaults(ctor);
        const typeIndex = ctor.TypeName in this._componentTypeIndices
            ? this._componentTypeIndices[ctor.TypeName]
            : this._componentTypes.length;
        this._componentTypes[typeIndex] = ctor;
        this._componentTypeIndices[ctor.TypeName] = typeIndex;
        console.log('Registered component', ctor.TypeName, `(class ${ctor.name})`, 'with index', typeIndex);
        if (ctor.onRegister)
            ctor.onRegister(this._engine);
        return typeIndex;
    }
    /**
     * Allocate the requested amount of temporary memory
     * in this WASM instance.
     *
     * @param size The number of bytes to allocate
     */
    allocateTempMemory(size) {
        console.log('Allocating temp mem:', size);
        this._tempMemSize = size;
        if (this._tempMem)
            this._free(this._tempMem);
        this._tempMem = this._malloc(this._tempMemSize);
        this.updateTempMemory();
    }
    /**
     * @todo: Delete this and only keep `allocateTempMemory`
     *
     * @param size Number of bytes to allocate
     */
    requireTempMem(size) {
        if (this._tempMemSize >= size)
            return;
        /* Grow in 1kb increments */
        this.allocateTempMemory(Math.ceil(size / 1024) * 1024);
    }
    /**
     * Update the temporary memory views. This must be called whenever the
     * temporary memory address changes.
     *
     * @note This api is meant to be used internally.
     */
    updateTempMemory() {
        this._tempMemFloat = new Float32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemInt = new Int32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint32 = new Uint32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint16 = new Uint16Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 1);
        this._tempMemUint8 = new Uint8Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize);
    }
    /**
     * Returns a uint8 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU8(count) {
        this.requireTempMem(count);
        return this._tempMemUint8;
    }
    /**
     * Returns a uint16 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU16(count) {
        this.requireTempMem(count * 2);
        return this._tempMemUint16;
    }
    /**
     * Returns a uint32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferU32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemUint32;
    }
    /**
     * Returns a int32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferI32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemInt;
    }
    /**
     * Returns a float32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferF32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemFloat;
    }
    /**
     * Copy the string into temporary WASM memory and retrieve the pointer.
     *
     * @note This method will compute the strlen and append a `\0`.
     *
     * @note The result should be used **directly** otherwise it might get
     * overridden by any next call modifying the temporary memory.
     *
     * @param str The string to write to temporary memory
     * @return The temporary pointer onto the WASM memory
     */
    tempUTF8(str) {
        const strLen = this.lengthBytesUTF8(str) + 1;
        this.requireTempMem(strLen);
        this.stringToUTF8(str, this._tempMem, strLen);
        return this._tempMem;
    }
    /**
     * Return the index of the component type.
     *
     * @note This method uses malloc and copies the string
     * to avoid overwriting caller's temporary data.
     *
     * @param type The type
     * @return The component type index
     */
    _typeIndexFor(type) {
        const lengthBytes = this.lengthBytesUTF8(type) + 1;
        const mem = this._malloc(lengthBytes);
        this.stringToUTF8(type, mem, lengthBytes);
        const componentType = this._wl_get_component_manager_index(mem);
        this._free(mem);
        return componentType;
    }
    /**
     * Return the name of component type stored at the given index.
     *
     * @param typeIndex The type index
     * @return The name as a string
     */
    _typeNameFor(typeIndex) {
        return this.UTF8ToString(this._wl_component_manager_name(typeIndex));
    }
    /**
     * Returns `true` if the runtime supports physx or not.
     */
    get withPhysX() {
        return this._withPhysX;
    }
    /**
     * Set the engine instance holding this bridge.
     *
     * @note This api is meant to be used internally.
     *
     * @param engine The engine instance.
     */
    _setEngine(engine) {
        this._engine = engine;
    }
    /* WebAssembly to JS call bridge. */
    _wljs_xr_session_start(mode) {
        this._engine.xr = new XR(this, mode);
        this._engine.onXRSessionStart.notify(this.webxr_session, mode);
    }
    _wljs_xr_session_end() {
        const startEmitter = this._engine.onXRSessionStart;
        if (startEmitter instanceof RetainEmitter)
            startEmitter.reset();
        this._engine.onXRSessionEnd.notify();
        this._engine.xr = null;
    }
    _wljs_xr_disable() {
        /* @todo This could directly be fully handled in JS. */
        this._engine.arSupported = false;
        this._engine.vrSupported = false;
    }
    _wljs_allocate(numComponents) {
        this._components = new Array(numComponents);
    }
    _wljs_init(withPhysX) {
        this._withPhysX = withPhysX;
        /* Target memory for JS API functions that return arrays */
        this.allocateTempMemory(1024);
    }
    _wljs_reallocate(numComponents) {
        if (numComponents > this._components.length) {
            this._components.length = numComponents;
        }
    }
    _wljs_scene_add_material_definition(definitionId) {
        const definition = new Map();
        /* Cache material definition for faster read/write */
        const nbParams = this._wl_material_definition_get_count(definitionId);
        for (let i = 0; i < nbParams; ++i) {
            const name = this.UTF8ToString(this._wl_material_definition_get_param_name(definitionId, i));
            const t = this._wl_material_definition_get_param_type(definitionId, i);
            definition.set(name, {
                index: i,
                type: {
                    type: t & 0xff,
                    componentCount: (t >> 8) & 0xff,
                    metaType: (t >> 16) & 0xff,
                },
            });
        }
        this._materialDefinitions[definitionId] = definition;
    }
    _wljs_set_component_param_bool(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v !== 0;
    }
    _wljs_set_component_param_int(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v;
    }
    _wljs_set_component_param_float(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v;
    }
    _wljs_set_component_param_string(c, p, pe, v, ve) {
        const param = this.UTF8ViewToString(p, pe);
        const value = this.UTF8ViewToString(v, ve);
        this._components[c][param] = value;
    }
    _wljs_set_component_param_color(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = new Float32Array([0, 8, 16, 24].map((s) => ((v >>> s) & 0xff) / 255.0));
    }
    _wljs_set_component_param_object(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? this._engine.wrapObject(v) : null;
    }
    _wljs_set_component_param_mesh(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Mesh(this._engine, v) : null;
    }
    _wljs_set_component_param_texture(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? this._engine.textures.wrap(v) : null;
    }
    _wljs_set_component_param_material(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Material(this._engine, v) : null;
    }
    _wljs_set_component_param_animation(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Animation(this._engine, v) : null;
    }
    _wljs_set_component_param_skin(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Skin(this._engine, v) : null;
    }
    _wljs_get_component_type_index(namePtr, nameEndPtr) {
        return this._componentTypeIndices[this.UTF8ViewToString(namePtr, nameEndPtr)];
    }
    _wljs_component_create(jsManagerIndex, index, id, type, object) {
        const ctor = this._componentTypes[type];
        const component = new ctor();
        /* Sets the manager and identifier from the outside, to simplify the user's constructor. */
        /* @ts-ignore */
        component._engine = this._engine;
        component._manager = jsManagerIndex;
        component._id = id;
        component._object = this._engine.wrapObject(object);
        this._components[index] = component;
        return component;
    }
    _wljs_component_init(component) {
        const c = this._components[component];
        if (c.init) {
            try {
                c.init();
            }
            catch (e) {
                console.error(`Exception during ${c.type} init() on object ${c.object.name}`);
                console.error(e);
            }
        }
        if (c.start) {
            /* Arm onActivate() with the initial start() call */
            const oldActivate = c.onActivate;
            c.onActivate = function () {
                /* As "component" is the component index, which may change
                 * through calls to init() and start(), we call it on the
                 * calling object, which will be the component, instead of
                 * wljs_component_start() etc */
                try {
                    if (this.start)
                        this.start();
                }
                catch (e) {
                    console.error(`Exception during ${this.type} start() on object ${this.object.name}`);
                    console.error(e);
                }
                this.onActivate = oldActivate;
                if (this.onActivate) {
                    try {
                        this.onActivate();
                    }
                    catch (e) {
                        console.error(`Exception during ${this.type} onActivate() on object ${this.object.name}`);
                        console.error(e);
                    }
                }
            };
        }
    }
    _wljs_component_update(component, dt) {
        const c = this._components[component];
        if (!c) {
            console.warn('WL: component was undefined:', component);
            this._components[component] = new Component(this._engine);
            return;
        }
        if (!c.update)
            return;
        try {
            c.update(dt);
        }
        catch (e) {
            console.error(`Exception during ${c.type} update() on object ${c.object.name}`);
            console.error(e);
            if (this._deactivate_component_on_error)
                c.active = false;
        }
    }
    _wljs_component_onActivate(component) {
        const c = this._components[component];
        if (!c || !c.onActivate)
            return;
        try {
            c.onActivate();
        }
        catch (e) {
            console.error(`Exception during ${c.type} onActivate() on object ${c.object.name}`);
            console.error(e);
        }
    }
    _wljs_component_onDeactivate(component) {
        const c = this._components[component];
        if (!c.onDeactivate)
            return;
        try {
            c.onDeactivate();
        }
        catch (e) {
            console.error(`Exception during ${c.type} onDeactivate() on object ${c.object.name}`);
            console.error(e);
        }
    }
    _wljs_component_onDestroy(component) {
        const c = this._components[component];
        if (!c.onDestroy)
            return;
        try {
            c.onDestroy();
        }
        catch (e) {
            console.error(`Exception during ${c.type} onDestroy() on object ${c.object.name}`);
            console.error(e);
        }
    }
    _wljs_swap(a, b) {
        const componentA = this._components[a];
        this._components[a] = this._components[b];
        this._components[b] = componentA;
    }
    /* JS to WebAssembly bridge. */
    HEAP8 = null;
    HEAPU8 = null;
    HEAPU16 = null;
    HEAPU32 = null;
    HEAP32 = null;
    HEAPF32 = null;
    GL = null;
    assert = null;
    _free = null;
    _malloc = null;
    lengthBytesUTF8 = null;
    stringToUTF8 = null;
    UTF8ToString = null;
    addFunction = null;
    removeFunction = null;
    _wl_set_error_callback = null;
    _wl_application_version = null;
    _wl_application_start = null;
    _wl_application_resize = null;
    _wl_nextUpdate = null;
    _wl_nextFrame = null;
    _wl_scene_get_active_views = null;
    _wl_scene_ray_cast = null;
    _wl_scene_add_object = null;
    _wl_scene_add_objects = null;
    _wl_scene_reserve_objects = null;
    _wl_scene_set_clearColor = null;
    _wl_scene_enableColorClear = null;
    _wl_set_loading_screen_progress = null;
    _wl_load_scene_bin = null;
    _wl_append_scene_bin = null;
    _wl_append_scene_gltf = null;
    _wl_scene_reset = null;
    _wl_component_get_object = null;
    _wl_component_setActive = null;
    _wl_component_isActive = null;
    _wl_component_remove = null;
    _wl_collision_component_get_collider = null;
    _wl_collision_component_set_collider = null;
    _wl_collision_component_get_extents = null;
    _wl_collision_component_get_group = null;
    _wl_collision_component_set_group = null;
    _wl_collision_component_query_overlaps = null;
    _wl_text_component_get_horizontal_alignment = null;
    _wl_text_component_set_horizontal_alignment = null;
    _wl_text_component_get_vertical_alignment = null;
    _wl_text_component_set_vertical_alignment = null;
    _wl_text_component_get_character_spacing = null;
    _wl_text_component_set_character_spacing = null;
    _wl_text_component_get_line_spacing = null;
    _wl_text_component_set_line_spacing = null;
    _wl_text_component_get_effect = null;
    _wl_text_component_set_effect = null;
    _wl_text_component_get_text = null;
    _wl_text_component_set_text = null;
    _wl_text_component_set_material = null;
    _wl_text_component_get_material = null;
    _wl_view_component_get_projection_matrix = null;
    _wl_view_component_get_near = null;
    _wl_view_component_set_near = null;
    _wl_view_component_get_far = null;
    _wl_view_component_set_far = null;
    _wl_view_component_get_fov = null;
    _wl_view_component_set_fov = null;
    _wl_input_component_get_type = null;
    _wl_input_component_set_type = null;
    _wl_light_component_get_color = null;
    _wl_light_component_get_type = null;
    _wl_light_component_set_type = null;
    _wl_light_component_get_intensity = null;
    _wl_light_component_set_intensity = null;
    _wl_light_component_get_outerAngle = null;
    _wl_light_component_set_outerAngle = null;
    _wl_light_component_get_innerAngle = null;
    _wl_light_component_set_innerAngle = null;
    _wl_light_component_get_shadows = null;
    _wl_light_component_set_shadows = null;
    _wl_light_component_get_shadowRange = null;
    _wl_light_component_set_shadowRange = null;
    _wl_light_component_get_shadowBias = null;
    _wl_light_component_set_shadowBias = null;
    _wl_light_component_get_shadowNormalBias = null;
    _wl_light_component_set_shadowNormalBias = null;
    _wl_light_component_get_shadowTexelSize = null;
    _wl_light_component_set_shadowTexelSize = null;
    _wl_light_component_get_cascadeCount = null;
    _wl_light_component_set_cascadeCount = null;
    _wl_animation_component_get_animation = null;
    _wl_animation_component_set_animation = null;
    _wl_animation_component_get_playCount = null;
    _wl_animation_component_set_playCount = null;
    _wl_animation_component_get_speed = null;
    _wl_animation_component_set_speed = null;
    _wl_animation_component_play = null;
    _wl_animation_component_stop = null;
    _wl_animation_component_pause = null;
    _wl_animation_component_state = null;
    _wl_mesh_component_get_material = null;
    _wl_mesh_component_set_material = null;
    _wl_mesh_component_get_mesh = null;
    _wl_mesh_component_set_mesh = null;
    _wl_mesh_component_get_skin = null;
    _wl_mesh_component_set_skin = null;
    _wl_physx_component_get_static = null;
    _wl_physx_component_set_static = null;
    _wl_physx_component_get_kinematic = null;
    _wl_physx_component_set_kinematic = null;
    _wl_physx_component_get_gravity = null;
    _wl_physx_component_set_gravity = null;
    _wl_physx_component_get_simulate = null;
    _wl_physx_component_set_simulate = null;
    _wl_physx_component_get_allowSimulation = null;
    _wl_physx_component_set_allowSimulation = null;
    _wl_physx_component_get_allowQuery = null;
    _wl_physx_component_set_allowQuery = null;
    _wl_physx_component_get_trigger = null;
    _wl_physx_component_set_trigger = null;
    _wl_physx_component_get_shape = null;
    _wl_physx_component_set_shape = null;
    _wl_physx_component_get_shape_data = null;
    _wl_physx_component_set_shape_data = null;
    _wl_physx_component_get_extents = null;
    _wl_physx_component_get_staticFriction = null;
    _wl_physx_component_set_staticFriction = null;
    _wl_physx_component_get_dynamicFriction = null;
    _wl_physx_component_set_dynamicFriction = null;
    _wl_physx_component_get_bounciness = null;
    _wl_physx_component_set_bounciness = null;
    _wl_physx_component_get_linearDamping = null;
    _wl_physx_component_set_linearDamping = null;
    _wl_physx_component_get_angularDamping = null;
    _wl_physx_component_set_angularDamping = null;
    _wl_physx_component_get_linearVelocity = null;
    _wl_physx_component_set_linearVelocity = null;
    _wl_physx_component_get_angularVelocity = null;
    _wl_physx_component_set_angularVelocity = null;
    _wl_physx_component_get_groupsMask = null;
    _wl_physx_component_set_groupsMask = null;
    _wl_physx_component_get_blocksMask = null;
    _wl_physx_component_set_blocksMask = null;
    _wl_physx_component_get_linearLockAxis = null;
    _wl_physx_component_set_linearLockAxis = null;
    _wl_physx_component_get_angularLockAxis = null;
    _wl_physx_component_set_angularLockAxis = null;
    _wl_physx_component_get_mass = null;
    _wl_physx_component_set_mass = null;
    _wl_physx_component_set_massSpaceInertiaTensor = null;
    _wl_physx_component_addForce = null;
    _wl_physx_component_addForceAt = null;
    _wl_physx_component_addTorque = null;
    _wl_physx_component_addCallback = null;
    _wl_physx_component_removeCallback = null;
    _wl_physx_update_global_pose = null;
    _wl_physx_ray_cast = null;
    _wl_physx_set_collision_callback = null;
    _wl_mesh_create = null;
    _wl_mesh_get_vertexData = null;
    _wl_mesh_get_vertexCount = null;
    _wl_mesh_get_indexData = null;
    _wl_mesh_update = null;
    _wl_mesh_get_boundingSphere = null;
    _wl_mesh_get_attribute = null;
    _wl_mesh_destroy = null;
    _wl_mesh_get_attribute_values = null;
    _wl_mesh_set_attribute_values = null;
    _wl_material_create = null;
    _wl_material_get_definition = null;
    _wl_material_definition_get_count = null;
    _wl_material_definition_get_param_name = null;
    _wl_material_definition_get_param_type = null;
    _wl_material_get_pipeline = null;
    _wl_material_clone = null;
    _wl_material_get_param_index = null;
    _wl_material_get_param_type = null;
    _wl_material_get_param_value = null;
    _wl_material_set_param_value_uint = null;
    _wl_material_set_param_value_float = null;
    _wl_renderer_addImage = null;
    _wl_texture_width = null;
    _wl_texture_height = null;
    _wl_renderer_updateImage = null;
    _wl_texture_destroy = null;
    _wl_animation_get_duration = null;
    _wl_animation_get_trackCount = null;
    _wl_animation_retargetToSkin = null;
    _wl_animation_retarget = null;
    _wl_object_name = null;
    _wl_object_set_name = null;
    _wl_object_parent = null;
    _wl_object_get_children_count = null;
    _wl_object_get_children = null;
    _wl_object_set_parent = null;
    _wl_object_reset_scaling = null;
    _wl_object_reset_translation_rotation = null;
    _wl_object_reset_rotation = null;
    _wl_object_reset_translation = null;
    _wl_object_translate = null;
    _wl_object_translate_obj = null;
    _wl_object_translate_world = null;
    _wl_object_rotate_axis_angle = null;
    _wl_object_rotate_axis_angle_rad = null;
    _wl_object_rotate_axis_angle_obj = null;
    _wl_object_rotate_axis_angle_rad_obj = null;
    _wl_object_rotate_quat = null;
    _wl_object_rotate_quat_obj = null;
    _wl_object_scale = null;
    _wl_object_trans_local = null;
    _wl_object_get_translation_local = null;
    _wl_object_set_translation_local = null;
    _wl_object_get_translation_world = null;
    _wl_object_set_translation_world = null;
    _wl_object_trans_world = null;
    _wl_object_trans_world_to_local = null;
    _wl_object_scaling_local = null;
    _wl_object_scaling_world = null;
    _wl_object_set_scaling_local = null;
    _wl_object_set_scaling_world = null;
    _wl_object_scaling_world_to_local = null;
    _wl_object_set_rotation_local = null;
    _wl_object_set_rotation_world = null;
    _wl_object_transformVectorWorld = null;
    _wl_object_transformVectorLocal = null;
    _wl_object_transformPointWorld = null;
    _wl_object_transformPointLocal = null;
    _wl_object_transformVectorInverseWorld = null;
    _wl_object_transformVectorInverseLocal = null;
    _wl_object_transformPointInverseWorld = null;
    _wl_object_transformPointInverseLocal = null;
    _wl_object_toWorldSpaceTransform = null;
    _wl_object_toObjectSpaceTransform = null;
    _wl_object_lookAt = null;
    _wl_scene_remove_object = null;
    _wl_object_set_dirty = null;
    _wl_get_component_manager_index = null;
    _wl_get_js_component_index = null;
    _wl_get_js_component_index_for_id = null;
    _wl_get_component_id = null;
    _wl_object_get_components = null;
    _wl_object_get_component_types = null;
    _wl_object_add_js_component = null;
    _wl_object_add_component = null;
    _wl_object_is_changed = null;
    _wl_component_manager_name = null;
    _wl_skin_get_joint_count = null;
    _wl_skin_joint_ids = null;
    _wl_skin_inverse_bind_transforms = null;
    _wl_skin_inverse_bind_scalings = null;
    _wl_math_cubicHermite = null;
    _wl_i18n_setLanguage = null;
    _wl_i18n_currentLanguage = null;
    _wl_i18n_translate = null;
    _wl_i18n_languageCount = null;
    _wl_i18n_languageIndex = null;
    _wl_i18n_languageCode = null;
    _wl_i18n_languageName = null;
}
