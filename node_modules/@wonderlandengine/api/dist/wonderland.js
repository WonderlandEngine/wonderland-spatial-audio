/**
 * Types
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { nativeProperty, enumerable } from './decorators.js';
import { isNumber, isString } from './utils/object.js';
import { Emitter } from './utils/event.js';
import { fetchWithProgress } from './utils/fetch.js';
/**
 * Wonderland Engine API
 * @namespace WL
 */
/**
 * Collider type enum for {@link CollisionComponent}.
 */
export var Collider;
(function (Collider) {
    /**
     * **Sphere Collider**:
     *
     * Simplest and most performant collision shape. If this type is set on a
     * {@link CollisionComponent}, only the first component of
     * {@link CollisionComponent#extents} will be used to determine the radius.
     */
    Collider[Collider["Sphere"] = 0] = "Sphere";
    /**
     * **Axis Aligned Bounding Box Collider**:
     *
     * Box that is always aligned to XYZ axis. It cannot be rotated but is more
     * efficient than {@link Collider.Box}.
     */
    Collider[Collider["AxisAlignedBox"] = 1] = "AxisAlignedBox";
    /**
     * **Aligned Bounding Box Collider**:
     *
     * Box that matches the object's rotation and translation correctly. This
     * is the least efficient collider and should only be chosen over
     * {@link Collider.Sphere} and {@link Collider.AxisAlignedBox} if really
     * necessary.
     */
    Collider[Collider["Box"] = 2] = "Box";
})(Collider || (Collider = {}));
/**
 * Alignment type enum for {@link TextComponent}.
 */
export var Alignment;
(function (Alignment) {
    /** Text start is at object origin */
    Alignment[Alignment["Left"] = 0] = "Left";
    /** Text center is at object origin */
    Alignment[Alignment["Center"] = 1] = "Center";
    /** Text end is at object origin */
    Alignment[Alignment["Right"] = 2] = "Right";
})(Alignment || (Alignment = {}));
/**
 * Justification type enum for {@link TextComponent}.
 */
export var Justification;
(function (Justification) {
    /** Text line is at object origin */
    Justification[Justification["Line"] = 0] = "Line";
    /** Text middle is at object origin */
    Justification[Justification["Middle"] = 1] = "Middle";
    /** Text top is at object origin */
    Justification[Justification["Top"] = 2] = "Top";
    /** Text bottom is at object origin */
    Justification[Justification["Bottom"] = 3] = "Bottom";
})(Justification || (Justification = {}));
/**
 * Effect type enum for {@link TextComponent}.
 */
export var TextEffect;
(function (TextEffect) {
    /** Text is rendered normally */
    TextEffect[TextEffect["None"] = 0] = "None";
    /** Text is rendered with an outline */
    TextEffect[TextEffect["Outline"] = 1] = "Outline";
})(TextEffect || (TextEffect = {}));
/**
 * Input type enum for {@link InputComponent}.
 */
export var InputType;
(function (InputType) {
    /** Head input */
    InputType[InputType["Head"] = 0] = "Head";
    /** Left eye input */
    InputType[InputType["EyeLeft"] = 1] = "EyeLeft";
    /** Right eye input */
    InputType[InputType["EyeRight"] = 2] = "EyeRight";
    /** Left controller input */
    InputType[InputType["ControllerLeft"] = 3] = "ControllerLeft";
    /** Right controller input */
    InputType[InputType["ControllerRight"] = 4] = "ControllerRight";
    /** Left ray input */
    InputType[InputType["RayLeft"] = 5] = "RayLeft";
    /** Right ray input */
    InputType[InputType["RayRight"] = 6] = "RayRight";
})(InputType || (InputType = {}));
/**
 * Light type enum for {@link LightComponent}.
 */
export var LightType;
(function (LightType) {
    /** Point light */
    LightType[LightType["Point"] = 0] = "Point";
    /** Spot light */
    LightType[LightType["Spot"] = 1] = "Spot";
    /** Sun light / Directional light */
    LightType[LightType["Sun"] = 2] = "Sun";
})(LightType || (LightType = {}));
/**
 * Animation state of {@link AnimationComponent}.
 */
export var AnimationState;
(function (AnimationState) {
    /** Animation is currently playing */
    AnimationState[AnimationState["Playing"] = 0] = "Playing";
    /** Animation is paused and will continue at current playback
     * time on {@link AnimationComponent#play} */
    AnimationState[AnimationState["Paused"] = 1] = "Paused";
    /** Animation is stopped */
    AnimationState[AnimationState["Stopped"] = 2] = "Stopped";
})(AnimationState || (AnimationState = {}));
/**
 * Rigid body force mode for {@link PhysXComponent#addForce} and {@link PhysXComponent#addTorque}.
 *
 * [PhysX API Reference](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/structPxForceMode.html)
 */
export var ForceMode;
(function (ForceMode) {
    /** Apply as force */
    ForceMode[ForceMode["Force"] = 0] = "Force";
    /** Apply as impulse */
    ForceMode[ForceMode["Impulse"] = 1] = "Impulse";
    /** Apply as velocity change, mass dependent */
    ForceMode[ForceMode["VelocityChange"] = 2] = "VelocityChange";
    /** Apply as mass dependent force */
    ForceMode[ForceMode["Acceleration"] = 3] = "Acceleration";
})(ForceMode || (ForceMode = {}));
/**
 * Collision callback event type.
 */
export var CollisionEventType;
(function (CollisionEventType) {
    /** Touch/contact detected, collision */
    CollisionEventType[CollisionEventType["Touch"] = 0] = "Touch";
    /** Touch/contact lost, uncollide */
    CollisionEventType[CollisionEventType["TouchLost"] = 1] = "TouchLost";
    /** Touch/contact with trigger detected */
    CollisionEventType[CollisionEventType["TriggerTouch"] = 2] = "TriggerTouch";
    /** Touch/contact with trigger lost */
    CollisionEventType[CollisionEventType["TriggerTouchLost"] = 3] = "TriggerTouchLost";
})(CollisionEventType || (CollisionEventType = {}));
/**
 * Rigid body {@link PhysXComponent#shape}.
 *
 * [PhysX SDK Guide](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html#geometry-types).
 */
export var Shape;
(function (Shape) {
    /** No shape. */
    Shape[Shape["None"] = 0] = "None";
    /** Sphere shape. */
    Shape[Shape["Sphere"] = 1] = "Sphere";
    /** Capsule shape. */
    Shape[Shape["Capsule"] = 2] = "Capsule";
    /** Box shape. */
    Shape[Shape["Box"] = 3] = "Box";
    /** Plane shape. */
    Shape[Shape["Plane"] = 4] = "Plane";
    /** Convex mesh shape. */
    Shape[Shape["ConvexMesh"] = 5] = "ConvexMesh";
    /** Triangle mesh shape. */
    Shape[Shape["TriangleMesh"] = 6] = "TriangleMesh";
})(Shape || (Shape = {}));
/**
 * Mesh attribute enum.
 * @since 0.9.0
 */
export var MeshAttribute;
(function (MeshAttribute) {
    /** Position attribute, 3 floats */
    MeshAttribute[MeshAttribute["Position"] = 0] = "Position";
    /** Tangent attribute, 4 floats */
    MeshAttribute[MeshAttribute["Tangent"] = 1] = "Tangent";
    /** Normal attribute, 3 floats */
    MeshAttribute[MeshAttribute["Normal"] = 2] = "Normal";
    /** Texture coordinate attribute, 2 floats */
    MeshAttribute[MeshAttribute["TextureCoordinate"] = 3] = "TextureCoordinate";
    /** Color attribute, 4 floats, RGBA, range `0` to `1` */
    MeshAttribute[MeshAttribute["Color"] = 4] = "Color";
    /** Joint id attribute, 8 unsigned ints */
    MeshAttribute[MeshAttribute["JointId"] = 5] = "JointId";
    /** Joint weights attribute, 8 floats */
    MeshAttribute[MeshAttribute["JointWeight"] = 6] = "JointWeight";
})(MeshAttribute || (MeshAttribute = {}));
/**
 * Material parameter type.
 */
export var MaterialParamType;
(function (MaterialParamType) {
    /** Unsigned integer parameter type. */
    MaterialParamType[MaterialParamType["UnsignedInt"] = 0] = "UnsignedInt";
    /** Integer parameter type. */
    MaterialParamType[MaterialParamType["Int"] = 1] = "Int";
    /** Float parameter type. */
    MaterialParamType[MaterialParamType["Float"] = 2] = "Float";
    /** Sampler resource parameter type, i.e., a {@link Texture}. */
    MaterialParamType[MaterialParamType["Sampler"] = 3] = "Sampler";
    /**
     * Font resource parameter type.
     *
     * **Note**: Changing font isn't exposed yet and will raise an error.
     */
    MaterialParamType[MaterialParamType["Font"] = 4] = "Font";
})(MaterialParamType || (MaterialParamType = {}));
/**
 * Check whether a given shape is a mesh or not.
 *
 * @param shape The shape to check.
 * @returns `true` if the shape is a mesh, `false` if it's a primitive.
 */
function isMeshShape(shape) {
    return shape === Shape.ConvexMesh || shape === Shape.TriangleMesh;
}
/**
 * Constants.
 */
/**
 * Default world up vector.
 */
const UP_VECTOR = [0, 1, 0];
/**
 * Provides global scene functionality like raycasting.
 */
export class Scene {
    /** Called before rendering the scene */
    onPreRender = new Emitter();
    /** Called after the scene has been rendered */
    onPostRender = new Emitter();
    /** Wonderland Engine instance. @hidden */
    _engine;
    /** Ray hit pointer in WASM heap. @hidden */
    _rayHit;
    /** Ray hit. @hidden */
    _hit;
    constructor(engine) {
        this._engine = engine;
        this._rayHit = engine.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
        this._hit = new RayHit(this._engine, this._rayHit);
    }
    /**
     * Currently active view components.
     */
    get activeViews() {
        const wasm = this._engine.wasm;
        const count = wasm._wl_scene_get_active_views(this._engine.wasm._tempMem, 16);
        const views = [];
        const viewTypeIndex = wasm._typeIndexFor('view');
        for (let i = 0; i < count; ++i) {
            views.push(new ViewComponent(this._engine, viewTypeIndex, this._engine.wasm._tempMemInt[i]));
        }
        return views;
    }
    /**
     * Cast a ray through the scene and find intersecting objects.
     *
     * The resulting ray hit will contain up to **4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     *
     * @returns The scene cached {@link RayHit} instance.
     * @note The returned object is owned by the Scene instance
     *   will be reused with the next {@link Scene#rayCast} call.
     */
    rayCast(o, d, group) {
        this._engine.wasm._wl_scene_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, this._rayHit);
        return this._hit;
    }
    /**
     * Add an object to the scene.
     *
     * @param parent Parent object or `null`.
     * @returns A newly created object.
     */
    addObject(parent = null) {
        const parentId = parent ? parent.objectId : 0;
        const objectId = this._engine.wasm._wl_scene_add_object(parentId);
        return this._engine.wrapObject(objectId);
    }
    /**
     * Batch-add objects to the scene.
     *
     * Will provide better performance for adding multiple objects (e.g. > 16)
     * than calling {@link Scene#addObject} repeatedly in a loop.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * convervatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param count Number of objects to add.
     * @param parent Parent object or `null`, default `null`.
     * @param componentCountHint Hint for how many components in total will
     *      be added to the created objects afterwards, default `0`.
     * @returns Newly created objects
     */
    addObjects(count, parent = null, componentCountHint = 0) {
        const parentId = parent ? parent.objectId : 0;
        this._engine.wasm.requireTempMem(count * 2);
        const actualCount = this._engine.wasm._wl_scene_add_objects(parentId, count, componentCountHint || 0, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
        const ids = this._engine.wasm._tempMemUint16.subarray(0, actualCount);
        const wrapper = this._engine.wrapObject.bind(this._engine);
        const objects = Array.from(ids, wrapper);
        return objects;
    }
    /**
     * Pre-allocate memory for a given amount of objects and components.
     *
     * Will provide better performance for adding objects later with {@link Scene#addObject}
     * and {@link Scene#addObjects}.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * conservatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param objectCount Number of objects to add.
     * @param componentCountPerType Amount of components to
     *      allocate for {@link Object3D.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
     * @since 0.8.10
     */
    reserveObjects(objectCount, componentCountPerType) {
        const wasm = this._engine.wasm;
        componentCountPerType = componentCountPerType || {};
        const jsManagerIndex = wasm._typeIndexFor('js');
        let countsPerTypeIndex = wasm._tempMemInt.subarray();
        countsPerTypeIndex.fill(0);
        for (const e of Object.entries(componentCountPerType)) {
            const typeIndex = wasm._typeIndexFor(e[0]);
            countsPerTypeIndex[typeIndex < 0 ? jsManagerIndex : typeIndex] += e[1];
        }
        wasm._wl_scene_reserve_objects(objectCount, wasm._tempMem);
    }
    /**
     * Set the background clear color.
     *
     * @param color new clear color (RGBA).
     * @since 0.8.5
     */
    set clearColor(color) {
        this._engine.wasm._wl_scene_set_clearColor(color[0], color[1], color[2], color[3]);
    }
    /**
     * Set whether to clear the color framebuffer before drawing.
     *
     * This function is useful if an external framework (e.g. an AR tracking
     * framework) is responsible for drawing a camera frame before Wonderland
     * Engine draws the scene on top of it.
     *
     * @param b Whether to enable color clear.
     * @since 0.9.4
     */
    set colorClearEnabled(b) {
        this._engine.wasm._wl_scene_enableColorClear(b);
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /**
     * Load a scene file (.bin).
     *
     * Will replace the currently active scene with the one loaded
     * from given file. It is assumed that JavaScript components required by
     * the new scene were registered in advance.
     *
     * Once the scene is loaded successfully and initialized,
     * {@link WonderlandEngine.onSceneLoaded} is notified.
     *
     * @param filename Path to the .bin file.
     * @returns Promise that resolves when the scene was loaded.
     */
    async load(filename) {
        const wasm = this._engine.wasm;
        const buffer = await fetchWithProgress(filename, (bytes, size) => {
            console.log(`Scene downloading: ${bytes} / ${size}`);
            wasm._wl_set_loading_screen_progress(bytes / size);
        });
        const size = buffer.byteLength;
        console.log(`Scene download of ${size} bytes successful.`);
        const ptr = wasm._malloc(size);
        new Uint8Array(wasm.HEAPU8.buffer, ptr, size).set(new Uint8Array(buffer));
        try {
            wasm._wl_load_scene_bin(ptr, size, wasm.tempUTF8(filename));
        }
        finally {
            /* Catch calls to abort(), e.g. via asserts */
            wasm._free(ptr);
        }
        const binQueue = wasm._queuedBinFiles;
        if (binQueue.length > 0) {
            wasm._queuedBinFiles = [];
            await Promise.all(binQueue.map((path) => this.append(path)));
        }
        this._engine.onSceneLoaded.notify();
    }
    /**
     * Append a scene file.
     *
     * Loads and parses the file and its images and appends the result
     * to the currently active scene.
     *
     * Supported formats are streamable Wonderland scene files (.bin) and glTF
     * 3D scenes (.gltf, .glb).
     *
     * ```js
     * WL.scene.append(filename).then(root => {
     *     // root contains the loaded scene
     * });
     * ```
     *
     * In case the `loadGltfExtensions` option is set to true, the response
     * will be an object containing both the root of the loaded scene and
     * any glTF extensions found on nodes, meshes and the root of the file.
     *
     * ```js
     * WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {
     *     // root contains the loaded scene
     *     // extensions.root contains any extensions at the root of glTF document
     *     const rootExtensions = extensions.root;
     *     // extensions.mesh and extensions.node contain extensions indexed by Object id
     *     const childObject = root.children[0];
     *     const meshExtensions = root.meshExtensions[childObject.objectId];
     *     const nodeExtensions = root.nodeExtensions[childObject.objectId];
     *     // extensions.idMapping contains a mapping from glTF node index to Object id
     * });
     * ```
     *
     * @param file The .bin, .gltf or .glb file to append. Should be a URL or
     *   an `ArrayBuffer` with the file content.
     * @param options Additional options for loading.
     * @returns Promise that resolves when the scene was appended.
     */
    async append(file, options) {
        const buffer = isString(file) ? await fetchWithProgress(file) : file;
        const wasm = this._engine.wasm;
        let callback;
        const promise = new Promise((resolve, reject) => {
            callback = wasm.addFunction((objectId, extensionData, extensionDataSize) => {
                if (objectId < 0) {
                    reject();
                    return;
                }
                const root = objectId ? this._engine.wrapObject(objectId) : null;
                if (extensionData && extensionDataSize) {
                    const marshalled = new Uint32Array(wasm.HEAPU32.buffer, extensionData, extensionDataSize / 4);
                    const extensions = this._unmarshallGltfExtensions(marshalled);
                    resolve({ root, extensions });
                }
                else {
                    resolve(root);
                }
            }, 'viii');
        }).finally(() => wasm.removeFunction(callback));
        const size = buffer.byteLength;
        const ptr = wasm._malloc(size);
        const data = new Uint8Array(wasm.HEAPU8.buffer, ptr, size);
        data.set(new Uint8Array(buffer));
        const MAGIC = 'WLEV';
        const isBinFile = data.byteLength > MAGIC.length &&
            data
                .subarray(0, MAGIC.length)
                .every((value, i) => value === MAGIC.charCodeAt(i));
        try {
            if (isBinFile) {
                wasm._wl_append_scene_bin(ptr, size, callback);
            }
            else {
                const loadExtensions = options?.loadGltfExtensions ?? false;
                wasm._wl_append_scene_gltf(ptr, size, loadExtensions, callback);
            }
        }
        catch (e) {
            wasm.removeFunction(callback);
            throw e;
        }
        finally {
            wasm._free(ptr);
        }
        const result = await promise;
        const binQueue = wasm._queuedBinFiles;
        if (isBinFile && binQueue.length > 0) {
            wasm._queuedBinFiles = [];
            await Promise.all(binQueue.map((path) => this.append(path, options)));
        }
        return result;
    }
    /**
     * Unmarshalls the GltfExtensions from an Uint32Array.
     *
     * @param data Array containing the gltf extension data.
     * @returns The extensions stored in an object literal.
     *
     * @hidden
     */
    _unmarshallGltfExtensions(data) {
        /* @todo: This method should be moved in the internal Emscripten library. */
        const extensions = {
            root: {},
            mesh: {},
            node: {},
            idMapping: [],
        };
        let index = 0;
        const readString = () => {
            const strPtr = data[index++];
            const strLen = data[index++];
            return this._engine.wasm.UTF8ViewToString(strPtr, strPtr + strLen);
        };
        const idMappingSize = data[index++];
        const idMapping = new Array(idMappingSize);
        for (let i = 0; i < idMappingSize; ++i) {
            idMapping[i] = data[index++];
        }
        extensions.idMapping = idMapping;
        const meshExtensionsSize = data[index++];
        for (let i = 0; i < meshExtensionsSize; ++i) {
            const objectId = data[index++];
            extensions.mesh[idMapping[objectId]] = JSON.parse(readString());
        }
        const nodeExtensionsSize = data[index++];
        for (let i = 0; i < nodeExtensionsSize; ++i) {
            const objectId = data[index++];
            extensions.node[idMapping[objectId]] = JSON.parse(readString());
        }
        const rootExtensionsStr = readString();
        if (rootExtensionsStr) {
            extensions.root = JSON.parse(rootExtensionsStr);
        }
        return extensions;
    }
    /**
     * Reset the scene.
     *
     * This method deletes all used and allocated objects, and components.
     */
    reset() {
        this._engine.wasm._wl_scene_reset();
    }
}
/**
 * Native component
 *
 * Provides access to a native component instance of a specified component type.
 *
 * Usage example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 *
 * export class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *     };
 *     start() {}
 *     onActivate() {}
 *     onDeactivate() {}
 *     update(dt) {}
 * }
 * ```
 */
export class Component {
    /**
     * Unique identifier for this component class.
     *
     * This is used to register, add, and retrieve components of a given type.
     */
    static TypeName;
    /**
     * Properties of this component class.
     *
     * Properties are public attributes that can be configured via the
     * Wonderland Editor.
     *
     * Example:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     * class MyComponent extends Component {
     *     static TypeName = 'my-component';
     *     static Properties = {
     *         myBoolean: { type: Type.Boolean, default: false },
     *         myFloat: { type: Type.Float, default: false },
     *         myTexture: { type: Type.Texture, default: null },
     *     };
     * }
     * ```
     *
     * Properties are automatically added to each component instance, and are
     * accessible like any JS attribute:
     *
     * ```js
     * // Creates a new component and set each properties value:
     * const myComponent = object.addComponent(MyComponent, {
     *     myBoolean: true,
     *     myFloat: 42.0,
     *     myTexture: null
     * });
     *
     * // You can also override the properties on the instance:
     * myComponent.myBoolean = false;
     * myComponent.myFloat = -42.0;
     * ```
     */
    static Properties;
    /**
     * This was never released in an official version, we are keeping it
     * to easy transition to the new API.
     *
     * @deprecated Use {@link Component.onRegister} instead.
     * @hidden
     */
    static Dependencies;
    /**
     * Called when this component class is registered.
     *
     * @example
     *
     * This callback can be used to register dependencies of a component,
     * e.g., component classes that need to be registered in order to add
     * them at runtime with {@link Object3D.addComponent}, independent of whether
     * they are used in the editor.
     *
     * ```js
     * class Spawner extends Component {
     *     static TypeName = 'spawner';
     *
     *     static onRegister() {
     *         engine.registerComponent(SpawnedComponent);
     *     }
     *
     *     // You can now use addComponent with SpawnedComponent
     * }
     * ```
     *
     * @example
     *
     * This callback can be used to register different implementations of a
     * component depending on client features or API versions.
     *
     * ```js
     * // Properties need to be the same for all implementations!
     * const SharedProperties = {};
     *
     * class Anchor extends Component {
     *     static TypeName = 'spawner';
     *     static Properties = SharedProperties;
     *
     *     static onRegister() {
     *         if(navigator.xr === undefined) {
     *             /* WebXR unsupported, keep this dummy component *\/
     *             return;
     *         }
     *         /* WebXR supported! Override already registered dummy implementation
     *          * with one depending on hit-test API support *\/
     *         engine.registerComponent(window.HitTestSource === undefined ?
     *             AnchorWithoutHitTest : AnchorWithHitTest);
     *     }
     *
     *     // This one implements no functions
     * }
     * ```
     */
    static onRegister;
    /** Manager index. @hidden */
    _manager;
    /** Instance index. @hidden */
    _id;
    /**
     * Object containing this object.
     *
     * **Note**: This is cached for faster retrieval.
     *
     * @hidden
     */
    _object;
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * Create a new instance
     *
     * @param engine The engine instance.
     * @param manager Index of the manager.
     * @param id WASM component instance index.
     *
     * @hidden
     */
    constructor(engine, manager = -1, id = -1) {
        this._engine = engine;
        this._manager = manager;
        this._id = id;
        this._object = null;
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /** The name of this component's type */
    get type() {
        const ctor = this.constructor;
        return ctor.TypeName ?? this._engine.wasm._typeNameFor(this._manager);
    }
    /** The object this component is attached to. */
    get object() {
        if (!this._object) {
            const objectId = this._engine.wasm._wl_component_get_object(this._manager, this._id);
            this._object = this._engine.wrapObject(objectId);
        }
        return this._object;
    }
    /**
     * Set whether this component is active.
     *
     * Activating/deactivating a component comes at a small cost of reordering
     * components in the respective component manager. This function therefore
     * is not a trivial assignment.
     *
     * Does nothing if the component is already activated/deactivated.
     *
     * @param active New active state.
     */
    set active(active) {
        this._engine.wasm._wl_component_setActive(this._manager, this._id, active);
    }
    /**
     * Whether this component is active
     */
    get active() {
        return this._engine.wasm._wl_component_isActive(this._manager, this._id) != 0;
    }
    /**
     * Remove this component from its objects and destroy it.
     *
     * It is best practice to set the component to `null` after,
     * to ensure it does not get used later.
     *
     * ```js
     *    c.destroy();
     *    c = null;
     * ```
     * @since 0.9.0
     */
    destroy() {
        this._engine.wasm._wl_component_remove(this._manager, this._id);
        this._manager = -1;
        this._id = -1;
    }
    /**
     * Checks equality by comparing whether the wrapped native component ids
     * and component manager types are equal.
     *
     * @param otherComponent Component to check equality with.
     * @returns Whether this component equals the given component.
     */
    equals(otherComponent) {
        if (!otherComponent)
            return false;
        return this._manager == otherComponent._manager && this._id == otherComponent._id;
    }
}
/**
 * Native collision component.
 *
 * Provides access to a native collision component instance.
 */
export class CollisionComponent extends Component {
    /** @override */
    static TypeName = 'collision';
    /** Collision component collider */
    get collider() {
        return this._engine.wasm._wl_collision_component_get_collider(this._id);
    }
    /**
     * Set collision component collider.
     *
     * @param collider Collider of the collision component.
     */
    set collider(collider) {
        this._engine.wasm._wl_collision_component_set_collider(this._id, collider);
    }
    /**
     * Collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the returned vector is used.
     */
    get extents() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_collision_component_get_extents(this._id), 3);
    }
    /**
     * Set collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the passed vector is used.
     *
     * Example:
     *
     * ```js
     * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
     * collision.extent = [1, 2, 3];
     * ```
     *
     * @param extents Extents of the collision component, expects a
     *      3 component array.
     */
    set extents(extents) {
        this.extents.set(extents);
    }
    /**
     * Collision component group.
     *
     * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
     * or the group in {@link Scene#rayCast}.
     *
     * Colliders that have no common groups will not overlap with each other. If a collider
     * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
     *
     * Each bit represents belonging to a group, see example.
     *
     * ```js
     *    // c belongs to group 2
     *    c.group = (1 << 2);
     *
     *    // c belongs to group 0
     *    c.group = (1 << 0);
     *
     *    // c belongs to group 0 *and* 2
     *    c.group = (1 << 0) | (1 << 2);
     *
     *    (c.group & (1 << 2)) != 0; // true
     *    (c.group & (1 << 7)) != 0; // false
     * ```
     */
    get group() {
        return this._engine.wasm._wl_collision_component_get_group(this._id);
    }
    /**
     * Set collision component group.
     *
     * @param group Group mask of the collision component.
     */
    set group(group) {
        this._engine.wasm._wl_collision_component_set_group(this._id, group);
    }
    /**
     * Query overlapping objects.
     *
     * Usage:
     *
     * ```js
     * const collision = object.getComponent('collision');
     * const overlaps = collision.queryOverlaps();
     * for(const otherCollision of overlaps) {
     *     const otherObject = otherCollision.object;
     *     console.log(`Collision with object ${otherObject.objectId}`);
     * }
     * ```
     *
     * @returns Collision components overlapping this collider.
     */
    queryOverlaps() {
        const count = this._engine.wasm._wl_collision_component_query_overlaps(this._id, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
        const overlaps = new Array(count);
        for (let i = 0; i < count; ++i) {
            overlaps[i] = new CollisionComponent(this._engine, this._manager, this._engine.wasm._tempMemUint16[i]);
        }
        return overlaps;
    }
}
__decorate([
    nativeProperty()
], CollisionComponent.prototype, "collider", null);
__decorate([
    nativeProperty()
], CollisionComponent.prototype, "extents", null);
__decorate([
    nativeProperty()
], CollisionComponent.prototype, "group", null);
/**
 * Native text component
 *
 * Provides access to a native text component instance
 */
export class TextComponent extends Component {
    /** @override */
    static TypeName = 'text';
    /** Text component alignment. */
    get alignment() {
        return this._engine.wasm._wl_text_component_get_horizontal_alignment(this._id);
    }
    /**
     * Set text component alignment.
     *
     * @param alignment Alignment for the text component.
     */
    set alignment(alignment) {
        this._engine.wasm._wl_text_component_set_horizontal_alignment(this._id, alignment);
    }
    /** Text component justification. */
    get justification() {
        return this._engine.wasm._wl_text_component_get_vertical_alignment(this._id);
    }
    /**
     * Set text component justification.
     *
     * @param justification Justification for the text component.
     */
    set justification(justification) {
        this._engine.wasm._wl_text_component_set_vertical_alignment(this._id, justification);
    }
    /** Text component character spacing. */
    get characterSpacing() {
        return this._engine.wasm._wl_text_component_get_character_spacing(this._id);
    }
    /**
     * Set text component character spacing.
     *
     * @param spacing Character spacing for the text component.
     */
    set characterSpacing(spacing) {
        this._engine.wasm._wl_text_component_set_character_spacing(this._id, spacing);
    }
    /** Text component line spacing. */
    get lineSpacing() {
        return this._engine.wasm._wl_text_component_get_line_spacing(this._id);
    }
    /**
     * Set text component line spacing
     *
     * @param spacing Line spacing for the text component
     */
    set lineSpacing(spacing) {
        this._engine.wasm._wl_text_component_set_line_spacing(this._id, spacing);
    }
    /** Text component effect. */
    get effect() {
        return this._engine.wasm._wl_text_component_get_effect(this._id);
    }
    /**
     * Set text component effect
     *
     * @param effect Effect for the text component
     */
    set effect(effect) {
        this._engine.wasm._wl_text_component_set_effect(this._id, effect);
    }
    /** Text component text. */
    get text() {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_text_component_get_text(this._id);
        return wasm.UTF8ToString(ptr);
    }
    /**
     * Set text component text.
     *
     * @param text Text of the text component.
     */
    set text(text) {
        const wasm = this._engine.wasm;
        wasm._wl_text_component_set_text(this._id, wasm.tempUTF8(text));
    }
    /**
     * Set material to render the text with.
     *
     * @param material New material.
     */
    set material(material) {
        const matIndex = material ? material._index : 0;
        this._engine.wasm._wl_text_component_set_material(this._id, matIndex);
    }
    /** Material used to render the text. */
    get material() {
        const id = this._engine.wasm._wl_text_component_get_material(this._id);
        return id > 0 ? new Material(this._engine, id) : null;
    }
}
__decorate([
    nativeProperty()
], TextComponent.prototype, "alignment", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "justification", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "characterSpacing", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "lineSpacing", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "effect", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "text", null);
__decorate([
    nativeProperty()
], TextComponent.prototype, "material", null);
/**
 * Native view component.
 *
 * Provides access to a native view component instance.
 */
export class ViewComponent extends Component {
    /** @override */
    static TypeName = 'view';
    /** Projection matrix. */
    get projectionMatrix() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_view_component_get_projection_matrix(this._id), 16);
    }
    /** ViewComponent near clipping plane value. */
    get near() {
        return this._engine.wasm._wl_view_component_get_near(this._id);
    }
    /**
     * Set near clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param near Near depth value.
     */
    set near(near) {
        this._engine.wasm._wl_view_component_set_near(this._id, near);
    }
    /** Far clipping plane value. */
    get far() {
        return this._engine.wasm._wl_view_component_get_far(this._id);
    }
    /**
     * Set far clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param far Near depth value.
     */
    set far(far) {
        this._engine.wasm._wl_view_component_set_far(this._id, far);
    }
    /**
     * Get the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, this returns the field of view reported by
     * the device, regardless of the fov that was set.
     */
    get fov() {
        return this._engine.wasm._wl_view_component_get_fov(this._id);
    }
    /**
     * Set the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, the field of view reported by the device is
     * used and this value is ignored. After the XR session ends, the new value
     * is applied.
     *
     * @param fov Horizontal field of view, **in degrees**.
     */
    set fov(fov) {
        this._engine.wasm._wl_view_component_set_fov(this._id, fov);
    }
}
__decorate([
    enumerable()
], ViewComponent.prototype, "projectionMatrix", null);
__decorate([
    nativeProperty()
], ViewComponent.prototype, "near", null);
__decorate([
    nativeProperty()
], ViewComponent.prototype, "far", null);
__decorate([
    nativeProperty()
], ViewComponent.prototype, "fov", null);
/**
 * Native input component.
 *
 * Provides access to a native input component instance.
 */
export class InputComponent extends Component {
    /** @override */
    static TypeName = 'input';
    /** Input component type */
    get inputType() {
        return this._engine.wasm._wl_input_component_get_type(this._id);
    }
    /**
     * Set input component type.
     *
     * @params New input component type.
     */
    set inputType(type) {
        this._engine.wasm._wl_input_component_set_type(this._id, type);
    }
    /**
     * WebXR Device API input source associated with this input component,
     * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
     */
    get xrInputSource() {
        const xrSession = this._engine.xrSession;
        if (xrSession) {
            for (let inputSource of xrSession.inputSources) {
                if (inputSource.handedness == this.handedness) {
                    return inputSource;
                }
            }
        }
        return null;
    }
    /**
     * 'left', 'right' or `null` depending on the {@link InputComponent#inputType}.
     */
    get handedness() {
        const inputType = this.inputType;
        if (inputType == InputType.ControllerRight ||
            inputType == InputType.RayRight ||
            inputType == InputType.EyeRight)
            return 'right';
        if (inputType == InputType.ControllerLeft ||
            inputType == InputType.RayLeft ||
            inputType == InputType.EyeLeft)
            return 'left';
        return null;
    }
}
__decorate([
    nativeProperty()
], InputComponent.prototype, "inputType", null);
__decorate([
    enumerable()
], InputComponent.prototype, "xrInputSource", null);
__decorate([
    enumerable()
], InputComponent.prototype, "handedness", null);
/**
 * Native light component.
 *
 * Provides access to a native light component instance.
 */
export class LightComponent extends Component {
    /** @override */
    static TypeName = 'light';
    getColor(out = new Float32Array(3)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_light_component_get_color(this._id) / 4; /* Align F32 */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        return out;
    }
    /**
     * Set light color.
     *
     * @param c New color array/vector, expected to have at least 3 elements.
     * @since 1.0.0
     */
    setColor(c) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_light_component_get_color(this._id) / 4; /* Align F32 */
        wasm.HEAPF32[ptr] = c[0];
        wasm.HEAPF32[ptr + 1] = c[1];
        wasm.HEAPF32[ptr + 2] = c[2];
    }
    /**
     * View on the light color.
     *
     * @note Prefer to use {@link getColor} in performance-critical code.
     */
    get color() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_light_component_get_color(this._id), 3);
    }
    /**
     * Set light color.
     *
     * @param c Color of the light component.
     *
     * @note Prefer to use {@link setColor} in performance-critical code.
     */
    set color(c) {
        this.color.set(c);
    }
    /** Light type. */
    get lightType() {
        return this._engine.wasm._wl_light_component_get_type(this._id);
    }
    /**
     * Set light type.
     *
     * @param lightType Type of the light component.
     */
    set lightType(t) {
        this._engine.wasm._wl_light_component_set_type(this._id, t);
    }
    /**
     * Light intensity.
     * @since 1.0.0
     */
    get intensity() {
        return this._engine.wasm._wl_light_component_get_intensity(this._id);
    }
    /**
     * Set light intensity.
     *
     * @param intensity Intensity of the light component.
     * @since 1.0.0
     */
    set intensity(intensity) {
        this._engine.wasm._wl_light_component_set_intensity(this._id, intensity);
    }
    /**
     * Outer angle for spot lights, in degrees.
     * @since 1.0.0
     */
    get outerAngle() {
        return this._engine.wasm._wl_light_component_get_outerAngle(this._id);
    }
    /**
     * Set outer angle for spot lights.
     *
     * @param angle Outer angle, in degrees.
     * @since 1.0.0
     */
    set outerAngle(angle) {
        this._engine.wasm._wl_light_component_set_outerAngle(this._id, angle);
    }
    /**
     * Inner angle for spot lights, in degrees.
     * @since 1.0.0
     */
    get innerAngle() {
        return this._engine.wasm._wl_light_component_get_innerAngle(this._id);
    }
    /**
     * Set inner angle for spot lights.
     *
     * @param angle Inner angle, in degrees.
     * @since 1.0.0
     */
    set innerAngle(angle) {
        this._engine.wasm._wl_light_component_set_innerAngle(this._id, angle);
    }
    /**
     * Whether the light casts shadows.
     * @since 1.0.0
     */
    get shadows() {
        return !!this._engine.wasm._wl_light_component_get_shadows(this._id);
    }
    /**
     * Set whether the light casts shadows.
     *
     * @param b Whether the light casts shadows.
     * @since 1.0.0
     */
    set shadows(b) {
        this._engine.wasm._wl_light_component_set_shadows(this._id, b);
    }
    /**
     * Range for shadows.
     * @since 1.0.0
     */
    get shadowRange() {
        return this._engine.wasm._wl_light_component_get_shadowRange(this._id);
    }
    /**
     * Set range for shadows.
     *
     * @param range Range for shadows.
     * @since 1.0.0
     */
    set shadowRange(range) {
        this._engine.wasm._wl_light_component_set_shadowRange(this._id, range);
    }
    /**
     * Bias value for shadows.
     * @since 1.0.0
     */
    get shadowBias() {
        return this._engine.wasm._wl_light_component_get_shadowBias(this._id);
    }
    /**
     * Set bias value for shadows.
     *
     * @param bias Bias for shadows.
     * @since 1.0.0
     */
    set shadowBias(bias) {
        this._engine.wasm._wl_light_component_set_shadowBias(this._id, bias);
    }
    /**
     * Normal bias value for shadows.
     * @since 1.0.0
     */
    get shadowNormalBias() {
        return this._engine.wasm._wl_light_component_get_shadowNormalBias(this._id);
    }
    /**
     * Set normal bias value for shadows.
     *
     * @param bias Normal bias for shadows.
     * @since 1.0.0
     */
    set shadowNormalBias(bias) {
        this._engine.wasm._wl_light_component_set_shadowNormalBias(this._id, bias);
    }
    /**
     * Texel size for shadows.
     * @since 1.0.0
     */
    get shadowTexelSize() {
        return this._engine.wasm._wl_light_component_get_shadowTexelSize(this._id);
    }
    /**
     * Set texel size for shadows.
     *
     * @param size Texel size for shadows.
     * @since 1.0.0
     */
    set shadowTexelSize(size) {
        this._engine.wasm._wl_light_component_set_shadowTexelSize(this._id, size);
    }
    /**
     * Cascade count for {@link LightType.Sun} shadows.
     * @since 1.0.0
     */
    get cascadeCount() {
        return this._engine.wasm._wl_light_component_get_cascadeCount(this._id);
    }
    /**
     * Set cascade count for {@link LightType.Sun} shadows.
     *
     * @param count Cascade count.
     * @since 1.0.0
     */
    set cascadeCount(count) {
        this._engine.wasm._wl_light_component_set_cascadeCount(this._id, count);
    }
}
__decorate([
    nativeProperty()
], LightComponent.prototype, "color", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "lightType", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "intensity", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "outerAngle", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "innerAngle", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "shadows", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "shadowRange", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "shadowBias", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "shadowNormalBias", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "shadowTexelSize", null);
__decorate([
    nativeProperty()
], LightComponent.prototype, "cascadeCount", null);
/**
 * Native animation component.
 *
 * Provides access to a native animation component instance.
 */
export class AnimationComponent extends Component {
    /** @override */
    static TypeName = 'animation';
    /**
     * Set animation to play.
     *
     * Make sure to {@link Animation#retarget} the animation to affect the
     * right objects.
     *
     * @param anim Animation to play.
     */
    set animation(anim) {
        this._engine.wasm._wl_animation_component_set_animation(this._id, anim ? anim._index : 0);
    }
    /** Animation set for this component */
    get animation() {
        const id = this._engine.wasm._wl_animation_component_get_animation(this._id);
        return id > 0 ? new Animation(this._engine, id) : null;
    }
    /**
     * Set play count. Set to `0` to loop indefinitely.
     *
     * @param playCount Number of times to repeat the animation.
     */
    set playCount(playCount) {
        this._engine.wasm._wl_animation_component_set_playCount(this._id, playCount);
    }
    /** Number of times the animation is played. */
    get playCount() {
        return this._engine.wasm._wl_animation_component_get_playCount(this._id);
    }
    /**
     * Set speed. Set to negative values to run the animation backwards.
     *
     * Setting speed has an immediate effect for the current frame's update
     * and will continue with the speed from the current point in the animation.
     *
     * @param speed New speed at which to play the animation.
     * @since 0.8.10
     */
    set speed(speed) {
        this._engine.wasm._wl_animation_component_set_speed(this._id, speed);
    }
    /**
     * Speed factor at which the animation is played.
     *
     * @since 0.8.10
     */
    get speed() {
        return this._engine.wasm._wl_animation_component_get_speed(this._id);
    }
    /** Current playing state of the animation */
    get state() {
        return this._engine.wasm._wl_animation_component_state(this._id);
    }
    /**
     * Play animation.
     *
     * If the animation is currently paused, resumes from that position. If the
     * animation is already playing, does nothing.
     *
     * To restart the animation, {@link AnimationComponent#stop} it first.
     */
    play() {
        this._engine.wasm._wl_animation_component_play(this._id);
    }
    /** Stop animation. */
    stop() {
        this._engine.wasm._wl_animation_component_stop(this._id);
    }
    /** Pause animation. */
    pause() {
        this._engine.wasm._wl_animation_component_pause(this._id);
    }
}
__decorate([
    nativeProperty()
], AnimationComponent.prototype, "animation", null);
__decorate([
    nativeProperty()
], AnimationComponent.prototype, "playCount", null);
__decorate([
    nativeProperty()
], AnimationComponent.prototype, "speed", null);
__decorate([
    enumerable()
], AnimationComponent.prototype, "state", null);
/**
 * Native mesh component.
 *
 * Provides access to a native mesh component instance.
 */
export class MeshComponent extends Component {
    /** @override */
    static TypeName = 'mesh';
    /**
     * Set material to render the mesh with.
     *
     * @param material Material to render the mesh with.
     */
    set material(material) {
        this._engine.wasm._wl_mesh_component_set_material(this._id, material ? material._index : 0);
    }
    /** Material used to render the mesh. */
    get material() {
        const id = this._engine.wasm._wl_mesh_component_get_material(this._id);
        return id > 0 ? new Material(this._engine, id) : null;
    }
    /** Mesh rendered by this component. */
    get mesh() {
        const id = this._engine.wasm._wl_mesh_component_get_mesh(this._id);
        return id > 0 ? new Mesh(this._engine, id) : null;
    }
    /**
     * Set mesh to rendered with this component.
     *
     * @param mesh Mesh rendered by this component.
     */
    set mesh(mesh) {
        this._engine.wasm._wl_mesh_component_set_mesh(this._id, mesh ? mesh._index : 0);
    }
    /** Skin for this mesh component. */
    get skin() {
        const id = this._engine.wasm._wl_mesh_component_get_skin(this._id);
        return id > 0 ? new Skin(this._engine, id) : null;
    }
    /**
     * Set skin to transform this mesh component.
     *
     * @param skin Skin to use for rendering skinned meshes.
     */
    set skin(skin) {
        this._engine.wasm._wl_mesh_component_set_skin(this._id, skin ? skin._index : 0);
    }
}
__decorate([
    nativeProperty()
], MeshComponent.prototype, "material", null);
__decorate([
    nativeProperty()
], MeshComponent.prototype, "mesh", null);
__decorate([
    nativeProperty()
], MeshComponent.prototype, "skin", null);
/**
 * Enum for Physics axes locking
 *
 * See {@link PhysXComponent.angularLockAxis} and {@link PhysXComponent.linearLockAxis}.
 */
export var LockAxis;
(function (LockAxis) {
    /**
     * No axis selected.
     */
    LockAxis[LockAxis["None"] = 0] = "None";
    /**
     * **X axis**:
     */
    LockAxis[LockAxis["X"] = 1] = "X";
    /**
     * **Y axis**:
     */
    LockAxis[LockAxis["Y"] = 2] = "Y";
    /**
     * **Z axis**:
     */
    LockAxis[LockAxis["Z"] = 4] = "Z";
})(LockAxis || (LockAxis = {}));
/**
 * Native physx rigid body component.
 *
 * Provides access to a native mesh component instance.
 * Only available when using physx enabled runtime, see "Project Settings > Runtime".
 */
export class PhysXComponent extends Component {
    /** @override */
    static TypeName = 'physx';
    /**
     * Set whether this rigid body is static.
     *
     * Setting this property only takes effect once the component
     * switches from inactive to active.
     *
     * @param b Whether the rigid body should be static.
     */
    set static(b) {
        this._engine.wasm._wl_physx_component_set_static(this._id, b);
    }
    /**
     * Whether this rigid body is static.
     *
     * This property returns whether the rigid body is *effectively*
     * static. If static property was set while the rigid body was
     * active, it will not take effect until the rigid body is set
     * inactive and active again. Until the component is set inactive,
     * this getter will return whether the rigid body is actually
     * static.
     */
    get static() {
        return !!this._engine.wasm._wl_physx_component_get_static(this._id);
    }
    /**
     * Set whether this rigid body is kinematic.
     *
     * @param b Whether the rigid body should be kinematic.
     */
    set kinematic(b) {
        this._engine.wasm._wl_physx_component_set_kinematic(this._id, b);
    }
    /**
     * Whether this rigid body is kinematic.
     */
    get kinematic() {
        return !!this._engine.wasm._wl_physx_component_get_kinematic(this._id);
    }
    /**
     * Set whether this rigid body's gravity is enabled.
     *
     * @param b Whether the rigid body's gravity should be enabled.
     */
    set gravity(b) {
        this._engine.wasm._wl_physx_component_set_gravity(this._id, b);
    }
    /**
     * Whether this rigid body's gravity flag is enabled.
     */
    get gravity() {
        return !!this._engine.wasm._wl_physx_component_get_gravity(this._id);
    }
    /**
     * Set whether this rigid body's simulate flag is enabled.
     *
     * @param b Whether the rigid body's simulate flag should be enabled.
     */
    set simulate(b) {
        this._engine.wasm._wl_physx_component_set_simulate(this._id, b);
    }
    /**
     * Whether this rigid body's simulate flag is enabled.
     */
    get simulate() {
        return !!this._engine.wasm._wl_physx_component_get_simulate(this._id);
    }
    /**
     * Set whether to allow simulation of this rigid body.
     *
     * {@link allowSimulation} and {@link trigger} can not be enabled at the
     * same time. Enabling {@link allowSimulation} while {@link trigger} is enabled
     * will disable {@link trigger}.
     *
     * @param b Whether to allow simulation of this rigid body.
     */
    set allowSimulation(b) {
        this._engine.wasm._wl_physx_component_set_allowSimulation(this._id, b);
    }
    /**
     * Whether to allow simulation of this rigid body.
     */
    get allowSimulation() {
        return !!this._engine.wasm._wl_physx_component_get_allowSimulation(this._id);
    }
    /**
     * Set whether this rigid body may be queried in ray casts.
     *
     * @param b Whether this rigid body may be queried in ray casts.
     */
    set allowQuery(b) {
        this._engine.wasm._wl_physx_component_set_allowQuery(this._id, b);
    }
    /**
     * Whether this rigid body may be queried in ray casts.
     */
    get allowQuery() {
        return !!this._engine.wasm._wl_physx_component_get_allowQuery(this._id);
    }
    /**
     * Set whether this physics body is a trigger.
     *
     * {@link allowSimulation} and {@link trigger} can not be enabled at the
     * same time. Enabling trigger while {@link allowSimulation} is enabled,
     * will disable {@link allowSimulation}.
     *
     * @param b Whether this physics body is a trigger.
     */
    set trigger(b) {
        this._engine.wasm._wl_physx_component_set_trigger(this._id, b);
    }
    /**
     * Whether this physics body is a trigger.
     */
    get trigger() {
        return !!this._engine.wasm._wl_physx_component_get_trigger(this._id);
    }
    /**
     * Set the shape for collision detection.
     *
     * @param s New shape.
     * @since 0.8.5
     */
    set shape(s) {
        this._engine.wasm._wl_physx_component_set_shape(this._id, s);
    }
    /** The shape for collision detection. */
    get shape() {
        return this._engine.wasm._wl_physx_component_get_shape(this._id);
    }
    /**
     * Set additional data for the shape.
     *
     * Retrieved only from {@link PhysXComponent#shapeData}.
     * @since 0.8.10
     */
    set shapeData(d) {
        if (d == null || !isMeshShape(this.shape))
            return;
        this._engine.wasm._wl_physx_component_set_shape_data(this._id, d.index);
    }
    /**
     * Additional data for the shape.
     *
     * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
     * `{index: n}` for `TriangleMesh` and `ConvexHull`.
     *
     * This data is currently only for passing onto or creating other {@link PhysXComponent}.
     * @since 0.8.10
     */
    get shapeData() {
        if (!isMeshShape(this.shape))
            return null;
        return { index: this._engine.wasm._wl_physx_component_get_shape_data(this._id) };
    }
    /**
     * Set the shape extents for collision detection.
     *
     * @param e New extents for the shape.
     * @since 0.8.5
     */
    set extents(e) {
        this.extents.set(e);
    }
    /**
     * The shape extents for collision detection.
     */
    get extents() {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_physx_component_get_extents(this._id);
        return new Float32Array(wasm.HEAPF32.buffer, ptr, 3);
    }
    /**
     * Get staticFriction.
     */
    get staticFriction() {
        return this._engine.wasm._wl_physx_component_get_staticFriction(this._id);
    }
    /**
     * Set staticFriction.
     * @param v New staticFriction.
     */
    set staticFriction(v) {
        this._engine.wasm._wl_physx_component_set_staticFriction(this._id, v);
    }
    /**
     * Get dynamicFriction.
     */
    get dynamicFriction() {
        return this._engine.wasm._wl_physx_component_get_dynamicFriction(this._id);
    }
    /**
     * Set dynamicFriction
     * @param v New dynamicDamping.
     */
    set dynamicFriction(v) {
        this._engine.wasm._wl_physx_component_set_dynamicFriction(this._id, v);
    }
    /**
     * Get bounciness.
     * @since 0.9.0
     */
    get bounciness() {
        return this._engine.wasm._wl_physx_component_get_bounciness(this._id);
    }
    /**
     * Set bounciness.
     * @param v New bounciness.
     * @since 0.9.0
     */
    set bounciness(v) {
        this._engine.wasm._wl_physx_component_set_bounciness(this._id, v);
    }
    /**
     * Get linearDamping/
     */
    get linearDamping() {
        return this._engine.wasm._wl_physx_component_get_linearDamping(this._id);
    }
    /**
     * Set linearDamping.
     * @param v New linearDamping.
     */
    set linearDamping(v) {
        this._engine.wasm._wl_physx_component_set_linearDamping(this._id, v);
    }
    /** Get angularDamping. */
    get angularDamping() {
        return this._engine.wasm._wl_physx_component_get_angularDamping(this._id);
    }
    /**
     * Set angularDamping.
     * @param v New angularDamping.
     */
    set angularDamping(v) {
        this._engine.wasm._wl_physx_component_set_angularDamping(this._id, v);
    }
    /**
     * Set linear velocity.
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New linear velocity.
     */
    set linearVelocity(v) {
        this._engine.wasm._wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);
    }
    /** Linear velocity or `[0, 0, 0]` if the component is not active. */
    get linearVelocity() {
        const wasm = this._engine.wasm;
        wasm._wl_physx_component_get_linearVelocity(this._id, wasm._tempMem);
        return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
    }
    /**
     * Set angular velocity
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New angular velocity
     */
    set angularVelocity(v) {
        this._engine.wasm._wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);
    }
    /** Angular velocity or `[0, 0, 0]` if the component is not active. */
    get angularVelocity() {
        const wasm = this._engine.wasm;
        wasm._wl_physx_component_get_angularVelocity(this._id, wasm._tempMem);
        return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
    }
    /**
     * Set the components groups mask.
     *
     * @param flags New flags that need to be set.
     */
    set groupsMask(flags) {
        this._engine.wasm._wl_physx_component_set_groupsMask(this._id, flags);
    }
    /**
     * Get the components groups mask flags.
     *
     * Each bit represents membership to group, see example.
     *
     * ```js
     * // Assign c to group 2
     * c.groupsMask = (1 << 2);
     *
     * // Assign c to group 0
     * c.groupsMask  = (1 << 0);
     *
     * // Assign c to group 0 and 2
     * c.groupsMask = (1 << 0) | (1 << 2);
     *
     * (c.groupsMask & (1 << 2)) != 0; // true
     * (c.groupsMask & (1 << 7)) != 0; // false
     * ```
     */
    get groupsMask() {
        return this._engine.wasm._wl_physx_component_get_groupsMask(this._id);
    }
    /**
     * Set the components blocks mask.
     *
     * @param flags New flags that need to be set.
     */
    set blocksMask(flags) {
        this._engine.wasm._wl_physx_component_set_blocksMask(this._id, flags);
    }
    /**
     * Get the components blocks mask flags.
     *
     * Each bit represents membership to the block, see example.
     *
     * ```js
     * // Block overlap with any objects in group 2
     * c.blocksMask = (1 << 2);
     *
     * // Block overlap with any objects in group 0
     * c.blocksMask  = (1 << 0)
     *
     * // Block overlap with any objects in group 0 and 2
     * c.blocksMask = (1 << 0) | (1 << 2);
     *
     * (c.blocksMask & (1 << 2)) != 0; // true
     * (c.blocksMask & (1 << 7)) != 0; // false
     * ```
     */
    get blocksMask() {
        return this._engine.wasm._wl_physx_component_get_blocksMask(this._id);
    }
    /**
     * Set axes to lock for linear velocity.
     *
     * @param lock The Axis that needs to be set.
     *
     * Combine flags with Bitwise OR.
     * ```js
     * body.linearLockAxis = LockAxis.X | LockAxis.Y; // x and y set
     * body.linearLockAxis = LockAxis.X; // y unset
     * ```
     *
     * @note This has no effect if the component is static.
     */
    set linearLockAxis(lock) {
        this._engine.wasm._wl_physx_component_set_linearLockAxis(this._id, lock);
    }
    /**
     * Get the linear lock axes flags.
     *
     * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
     *
     * ```js
     * if(body.linearLockAxis & LockAxis.Y) {
     *     console.log("The Y flag was set!");
     * }
     * ```
     *
     * @return axes that are currently locked for linear movement.
     */
    get linearLockAxis() {
        return this._engine.wasm._wl_physx_component_get_linearLockAxis(this._id);
    }
    /**
     * Set axes to lock for angular velocity.
     *
     * @param lock The Axis that needs to be set.
     *
     * ```js
     * body.angularLockAxis = LockAxis.X | LockAxis.Y; // x and y set
     * body.angularLockAxis = LockAxis.X; // y unset
     * ```
     *
     * @note This has no effect if the component is static.
     */
    set angularLockAxis(lock) {
        this._engine.wasm._wl_physx_component_set_angularLockAxis(this._id, lock);
    }
    /**
     * Get the angular lock axes flags.
     *
     * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
     *
     * ```js
     * if(body.angularLockAxis & LockAxis.Y) {
     *     console.log("The Y flag was set!");
     * }
     * ```
     *
     * @return axes that are currently locked for angular movement.
     */
    get angularLockAxis() {
        return this._engine.wasm._wl_physx_component_get_angularLockAxis(this._id);
    }
    /**
     * Set mass.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * @param m New mass.
     */
    set mass(m) {
        this._engine.wasm._wl_physx_component_set_mass(this._id, m);
    }
    /** Mass */
    get mass() {
        return this._engine.wasm._wl_physx_component_get_mass(this._id);
    }
    /**
     * Set mass space interia tensor.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New mass space interatia tensor.
     */
    set massSpaceInteriaTensor(v) {
        this._engine.wasm._wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);
    }
    /**
     * Apply a force.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     * @param localForce Whether the force vector is in local space, default `false`.
     * @param p Position to apply force at, default is center of mass.
     * @param local Whether position is in local space, default `false`.
     */
    addForce(f, m = ForceMode.Force, localForce = false, p, local = false) {
        const wasm = this._engine.wasm;
        if (!p) {
            wasm._wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, localForce);
            return;
        }
        wasm._wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, localForce, p[0], p[1], p[2], local);
    }
    /**
     * Apply torque.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     */
    addTorque(f, m = ForceMode.Force) {
        this._engine.wasm._wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);
    }
    /**
     * Add on collision callback.
     *
     * @param callback Function to call when this rigid body (un)collides with any other.
     *
     * ```js
     *  let rigidBody = this.object.getComponent('physx');
     *  rigidBody.onCollision(function(type, other) {
     *      // Ignore uncollides
     *      if(type == CollisionEventType.TouchLost) return;
     *
     *      // Take damage on collision with enemies
     *      if(other.object.name.startsWith('enemy-')) {
     *          this.applyDamage(10);
     *      }
     *  }.bind(this));
     * ```
     *
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollision(callback) {
        return this.onCollisionWith(this, callback);
    }
    /**
     * Add filtered on collision callback.
     *
     * @param otherComp Component for which callbacks will
     *        be triggered. If you pass this component, the method is equivalent to.
     *        {@link PhysXComponent#onCollision}.
     * @param callback Function to call when this rigid body
     *        (un)collides with `otherComp`.
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollisionWith(otherComp, callback) {
        const physics = this._engine.physics;
        physics._callbacks[this._id] = physics._callbacks[this._id] || [];
        physics._callbacks[this._id].push(callback);
        return this._engine.wasm._wl_physx_component_addCallback(this._id, otherComp._id || this._id);
    }
    /**
     * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     *
     * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     * @throws When the callback does not belong to the component.
     * @throws When the callback does not exist.
     */
    removeCollisionCallback(callbackId) {
        const physics = this._engine.physics;
        const r = this._engine.wasm._wl_physx_component_removeCallback(this._id, callbackId);
        /* r is the amount of object to remove from the end of the
         * callbacks array for this object */
        if (r)
            physics._callbacks[this._id].splice(-r);
    }
}
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "static", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "kinematic", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "gravity", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "simulate", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "allowSimulation", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "allowQuery", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "trigger", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "shape", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "shapeData", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "extents", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "staticFriction", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "dynamicFriction", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "bounciness", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "linearDamping", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "angularDamping", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "linearVelocity", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "angularVelocity", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "groupsMask", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "blocksMask", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "linearLockAxis", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "angularLockAxis", null);
__decorate([
    nativeProperty()
], PhysXComponent.prototype, "mass", null);
/**
 * Access to the physics scene
 */
export class Physics {
    /**
     * @hidden
     *
     * **Note**: This is public to emulate a `friend` accessor.
     */
    _callbacks;
    /** Wonderland Engine instance */
    _engine;
    /** Ray Hit */
    _rayHit;
    /** Hit. */
    _hit;
    constructor(engine) {
        this._engine = engine;
        this._rayHit = engine.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
        this._hit = new RayHit(this._engine, this._rayHit);
        this._callbacks = {};
    }
    /**
     * Cast a ray through the physics scene and find intersecting objects.
     *
     * The resulting ray hit will contain **up to 4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     * @param maxDistance Maximum ray distance, default `100.0`.
     *
     * @returns The RayHit instance, belonging to this class.
     *
     * @note The returned {@link RayHit} object is owned by the Physics instance and
     *       will be reused with the next {@link Physics#rayCast} call.
     */
    rayCast(o, d, group, maxDistance = 100.0) {
        this._engine.wasm._wl_physx_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, maxDistance, this._rayHit);
        return this._hit;
    }
}
/**
 * Mesh index type.
 */
export var MeshIndexType;
(function (MeshIndexType) {
    /** Single byte mesh index, range 0-255 */
    MeshIndexType[MeshIndexType["UnsignedByte"] = 1] = "UnsignedByte";
    /** Two byte mesh index, range 0-65535 */
    MeshIndexType[MeshIndexType["UnsignedShort"] = 2] = "UnsignedShort";
    /** Four byte mesh index, range 0-4294967295 */
    MeshIndexType[MeshIndexType["UnsignedInt"] = 4] = "UnsignedInt";
})(MeshIndexType || (MeshIndexType = {}));
/**
 * Mesh skinning type.
 */
export var MeshSkinningType;
(function (MeshSkinningType) {
    /** Not skinned */
    MeshSkinningType[MeshSkinningType["None"] = 0] = "None";
    /** Skinned, 4 joints/weight per vertex */
    MeshSkinningType[MeshSkinningType["FourJoints"] = 1] = "FourJoints";
    /** Skinned, 8 joints/weight per vertex */
    MeshSkinningType[MeshSkinningType["EightJoints"] = 2] = "EightJoints";
})(MeshSkinningType || (MeshSkinningType = {}));
/**
 * Wrapper around a native mesh data.
 *
 * To modify a mesh, you get access to a {@link MeshAttributeAccessor} that allows you to modify
 * the content of the buffers:
 *
 * Usage:
 *
 * ```js
 * const mesh = new Mesh(engine, {vertexCount: 3, indexData: [0, 1, 2] });
 * const positions = mesh.attribute(MeshAttribute.Position);
 * ...
 * ```
 */
export class Mesh {
    /**
     * Index of the mesh in the manager.
     *
     * @hidden
     */
    _index = -1;
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * Create a new instance.
     *
     * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
     *    For more information, please have a look at the {@link MeshParameters} interface.
     */
    constructor(engine, params) {
        this._engine = engine ?? WL;
        this._index = -1;
        if (isNumber(params)) {
            this._index = params;
            return;
        }
        if (!params.vertexCount)
            throw new Error("Missing parameter 'vertexCount'");
        const wasm = this._engine.wasm;
        let indexData = 0;
        let indexType = 0;
        let indexDataSize = 0;
        if (params.indexData) {
            indexType = params.indexType || MeshIndexType.UnsignedShort;
            indexDataSize = params.indexData.length * indexType;
            indexData = wasm._malloc(indexDataSize);
            /* Copy the index data into wasm memory */
            switch (indexType) {
                case MeshIndexType.UnsignedByte:
                    wasm.HEAPU8.set(params.indexData, indexData);
                    break;
                case MeshIndexType.UnsignedShort:
                    wasm.HEAPU16.set(params.indexData, indexData >> 1);
                    break;
                case MeshIndexType.UnsignedInt:
                    wasm.HEAPU32.set(params.indexData, indexData >> 2);
                    break;
            }
        }
        const { skinningType = MeshSkinningType.None } = params;
        this._index = wasm._wl_mesh_create(indexData, indexDataSize, indexType, params.vertexCount, skinningType);
    }
    /** Number of vertices in this mesh. */
    get vertexCount() {
        return this._engine.wasm._wl_mesh_get_vertexCount(this._index);
    }
    /** Index data (read-only) or `null` if the mesh is not indexed. */
    get indexData() {
        const wasm = this._engine.wasm;
        const tempMem = wasm._tempMem;
        const ptr = wasm._wl_mesh_get_indexData(this._index, tempMem, tempMem + 4);
        if (ptr === null)
            return null;
        const indexCount = wasm.HEAPU32[tempMem / 4];
        const indexSize = wasm.HEAPU32[tempMem / 4 + 1];
        switch (indexSize) {
            case MeshIndexType.UnsignedByte:
                return new Uint8Array(wasm.HEAPU8.buffer, ptr, indexCount);
            case MeshIndexType.UnsignedShort:
                return new Uint16Array(wasm.HEAPU16.buffer, ptr, indexCount);
            case MeshIndexType.UnsignedInt:
                return new Uint32Array(wasm.HEAPU32.buffer, ptr, indexCount);
        }
        return null;
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /**
     * Apply changes to {@link attribute | vertex attributes}.
     *
     * Uploads the updated vertex attributes to the GPU and updates the bounding
     * sphere to match the new vertex positions.
     *
     * Since this is an expensive operation, call it only once you have performed
     * all modifications on a mesh and avoid calling if you did not perform any
     * modifications at all.
     */
    update() {
        this._engine.wasm._wl_mesh_update(this._index);
    }
    getBoundingSphere(out = new Float32Array(4)) {
        const tempMemFloat = this._engine.wasm._tempMemFloat;
        this._engine.wasm._wl_mesh_get_boundingSphere(this._index, this._engine.wasm._tempMem);
        out[0] = tempMemFloat[0];
        out[1] = tempMemFloat[1];
        out[2] = tempMemFloat[2];
        out[3] = tempMemFloat[3];
        return out;
    }
    attribute(attr) {
        if (typeof attr != 'number')
            throw new TypeError('Expected number, but got ' + typeof attr);
        const tempMemUint32 = this._engine.wasm._tempMemUint32;
        this._engine.wasm._wl_mesh_get_attribute(this._index, attr, this._engine.wasm._tempMem);
        if (tempMemUint32[0] == 255)
            return null;
        const arraySize = tempMemUint32[5];
        return new MeshAttributeAccessor(this._engine, {
            attribute: tempMemUint32[0],
            offset: tempMemUint32[1],
            stride: tempMemUint32[2],
            formatSize: tempMemUint32[3],
            componentCount: tempMemUint32[4],
            /* The WASM API returns `0` for a scalar value. We clamp it to 1 as we strictly use it as a multiplier for get/set operations */
            arraySize: arraySize ? arraySize : 1,
            length: this.vertexCount,
            bufferType: (attr !== MeshAttribute.JointId
                ? Float32Array
                : Uint16Array),
        });
    }
    /**
     * Destroy and free the meshes memory.
     *
     * It is best practice to set the mesh variable to `null` after calling
     * destroy to prevent accidental use:
     *
     * ```js
     *   mesh.destroy();
     *   mesh = null;
     * ```
     *
     * Accessing the mesh after destruction behaves like accessing an empty
     * mesh.
     *
     * @since 0.9.0
     */
    destroy() {
        this._engine.wasm._wl_mesh_destroy(this._index);
    }
    /**
     * Checks equality by comparing whether the wrapped native mesh ids are
     * equal.
     *
     * @param otherMesh Mesh to check equality with.
     * @returns Whether this mesh equals the given mesh.
     *
     * @since 1.0.0
     */
    equals(otherMesh) {
        if (!otherMesh)
            return false;
        return this._index === otherMesh._index;
    }
}
/**
 * An iterator over a mesh vertex attribute.
 *
 * Usage:
 *
 * ```js
 *   const mesh = this.object.getComponent('mesh').mesh;
 *   const positions = mesh.attribute(WL.MeshAttribute.Position);
 *
 *   const temp = new Float32Array(3);
 *   for(int i = 0; i < positions.length; ++i) {
 *       // pos will reference temp and thereby not allocate additional
 *       // JavaScript garbage, which would cause a perf spike when collected.
 *       const pos = positions.get(i, temp);
 *       // scale position by 2 on X axis only
 *       pos[0] *= 2.0f;
 *       positions.set(i, pos);
 *   }
 *   // we're done modifying, tell the engine to move vertex data to the GPU
 *   mesh.update();
 * ```
 */
export class MeshAttributeAccessor {
    /** Max number of elements. */
    length = 0;
    /** Wonderland Engine instance. @hidden */
    _engine;
    /** Attribute index. @hidden */
    _attribute = -1;
    /** Attribute offset. @hidden */
    _offset = 0;
    /** Attribute stride. @hidden */
    _stride = 0;
    /** Format size native enum. @hidden */
    _formatSize = 0;
    /** Number of components per vertex. @hidden */
    _componentCount = 0;
    /** Number of values per vertex. @hidden */
    _arraySize = 1;
    /**
     * Class to instantiate an ArrayBuffer to get/set values.
     */
    _bufferType;
    /**
     * Function to allocate temporary WASM memory. It is cached in the accessor to avoid
     * conditionals during get/set.
     */
    _tempBufferGetter;
    /**
     * Create a new instance.
     *
     * @note Please use {@link Mesh.attribute} to create a new instance.
     *
     * @param options Contains information about how to read the data.
     * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
     *
     * @hidden
     */
    constructor(engine, options) {
        this._engine = engine;
        const wasm = this._engine.wasm;
        this._attribute = options.attribute;
        this._offset = options.offset;
        this._stride = options.stride;
        this._formatSize = options.formatSize;
        this._componentCount = options.componentCount;
        this._arraySize = options.arraySize;
        this._bufferType = options.bufferType;
        this.length = options.length;
        this._tempBufferGetter = (this._bufferType === Float32Array
            ? wasm.getTempBufferF32.bind(wasm)
            : wasm.getTempBufferU16.bind(wasm));
    }
    /**
     * Create a new TypedArray to hold this attribute's values.
     *
     * This method is useful to create a view to hold the data to
     * pass to {@link get} and {@link set}
     *
     * Example:
     *
     * ```js
     * const vertexCount = 4;
     * const positionAttribute = mesh.attribute(MeshAttributes.Position);
     *
     * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
     * const positions = positionAttribute.createArray(vertexCount);
     * ```
     *
     * @param count The number of **vertices** expected.
     * @returns A TypedArray with the appropriate format to access the data
     */
    createArray(count = 1) {
        count = count > this.length ? this.length : count;
        return new this._bufferType(count * this._componentCount * this._arraySize);
    }
    get(index, out = this.createArray()) {
        if (out.length % this._componentCount !== 0) {
            throw new Error(`out.length, ${out.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
        }
        const dest = this._tempBufferGetter(out.length);
        const elementSize = this._bufferType.BYTES_PER_ELEMENT;
        const destSize = elementSize * out.length;
        const srcFormatSize = this._formatSize * this._arraySize;
        const destFormatSize = this._componentCount * elementSize * this._arraySize;
        this._engine.wasm._wl_mesh_get_attribute_values(this._attribute, srcFormatSize, this._offset + index * this._stride, this._stride, destFormatSize, dest.byteOffset, destSize);
        for (let i = 0; i < out.length; ++i)
            out[i] = dest[i];
        return out;
    }
    /**
     * Set attribute element.
     *
     * @param i Index
     * @param v Value to set the element to
     *
     * `v.length` needs to be a multiple of the attributes component count, see
     * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
     * filled with the next n attribute elements, which can reduce overhead
     * of this call.
     *
     * @returns Reference to self (for method chaining)
     */
    set(i, v) {
        if (v.length % this._componentCount !== 0)
            throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
        const elementSize = this._bufferType.BYTES_PER_ELEMENT;
        const srcSize = elementSize * v.length;
        const srcFormatSize = this._componentCount * elementSize * this._arraySize;
        const destFormatSize = this._formatSize * this._arraySize;
        const wasm = this._engine.wasm;
        /* Unless we are already working with data from WASM heap, we
         * need to copy into temporary memory. */
        if (v.buffer != wasm.HEAPU8.buffer) {
            const dest = this._tempBufferGetter(v.length);
            dest.set(v);
            v = dest;
        }
        wasm._wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, srcSize, destFormatSize, this._offset + i * this._stride, this._stride);
        return this;
    }
}
/**
 * Wrapper around a native material.
 *
 * Each material instance will have properties associated to the pipeline it uses.
 * The material properties are automatically added to each material instance, example:
 *
 * ```js
 * const material = mesh.material; // Material with a `Phong Opaque Textured` pipeline
 * // You can access all the material properties from the editor using:
 * material.diffuseTexture = null;
 * material.diffuseColor = [1.0, 0.0, 0.0, 1.0];
 * ```
 */
export class Material {
    /**
     * Index of this material in the manager.
     *
     * @hidden
     */
    _index;
    /**
     * Material definition index in the scene.
     *
     * @hidden
     */
    _definition;
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * Create a new Material.
     *
     * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
     * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
     */
    constructor(engine, params) {
        this._engine = engine;
        if (typeof params !== 'number') {
            if (!params?.pipeline)
                throw new Error("Missing parameter 'pipeline'");
            const wasm = this._engine.wasm;
            const pipeline = params.pipeline;
            this._index = wasm._wl_material_create(wasm.tempUTF8(pipeline));
            if (this._index < 0)
                throw new Error(`No such pipeline '${pipeline}'`);
        }
        else {
            this._index = params;
        }
        this._definition = this._engine.wasm._wl_material_get_definition(this._index);
        if (!this._engine.wasm._materialDefinitions[this._definition])
            throw new Error(`Material Definition ${this._definition} not found for material with index ${this._index}`);
        return new Proxy(this, {
            get(target, prop) {
                const wasm = engine.wasm;
                const definition = wasm._materialDefinitions[target._definition];
                const param = definition.get(prop);
                if (!param)
                    return target[prop];
                if (wasm._wl_material_get_param_value(target._index, param.index, wasm._tempMem)) {
                    const type = param.type;
                    switch (type.type) {
                        case MaterialParamType.UnsignedInt:
                            return type.componentCount == 1
                                ? wasm._tempMemUint32[0]
                                : new Uint32Array(wasm.HEAPU32.buffer, wasm._tempMem, type.componentCount);
                        case MaterialParamType.Int:
                            return type.componentCount == 1
                                ? wasm._tempMemInt[0]
                                : new Int32Array(wasm.HEAP32.buffer, wasm._tempMem, type.componentCount);
                        case MaterialParamType.Float:
                            return type.componentCount == 1
                                ? wasm._tempMemFloat[0]
                                : new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, type.componentCount);
                        case MaterialParamType.Sampler:
                            return engine.textures.wrap(wasm._tempMemInt[0]);
                        default:
                            throw new Error(`Invalid type ${type.type} on parameter ${param.index} for material ${target._index}`);
                    }
                }
            },
            set(target, prop, value) {
                const wasm = engine.wasm;
                const definition = wasm._materialDefinitions[target._definition];
                const param = definition.get(prop);
                if (!param) {
                    target[prop] = value;
                    return true;
                }
                const type = param.type;
                switch (type.type) {
                    case MaterialParamType.UnsignedInt:
                    case MaterialParamType.Int:
                    case MaterialParamType.Sampler:
                        const v = value.id ?? value;
                        wasm._wl_material_set_param_value_uint(target._index, param.index, v);
                        break;
                    case MaterialParamType.Float:
                        let count = 1;
                        if (typeof value === 'number') {
                            wasm._tempMemFloat[0] = value;
                        }
                        else {
                            count = value.length;
                            for (let i = 0; i < count; ++i)
                                wasm._tempMemFloat[i] = value[i];
                        }
                        wasm._wl_material_set_param_value_float(target._index, param.index, wasm._tempMem, count);
                        break;
                    case MaterialParamType.Font:
                        throw new Error('Setting font properties is currently unsupported.');
                }
                return true;
            },
        });
    }
    /** @deprecated Use {@link #pipeline} instead. */
    get shader() {
        return this.pipeline;
    }
    /** Name of the pipeline used by this material. */
    get pipeline() {
        const wasm = this._engine.wasm;
        return wasm.UTF8ToString(wasm._wl_material_get_pipeline(this._index));
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /**
     * Create a copy of the underlying native material.
     *
     * @returns Material clone.
     */
    clone() {
        const id = this._engine.wasm._wl_material_clone(this._index);
        return id > 0 ? new Material(this._engine, id) : null;
    }
    /**
     * Checks equality by comparing whether the wrapped native material ids are
     * equal.
     *
     * @param otherMaterial Material to check equality with.
     * @returns Whether this material equals the given material.
     *
     * @since 1.0.0
     */
    equals(otherMaterial) {
        if (!otherMaterial)
            return false;
        return this._index === otherMaterial._index;
    }
    /**
     * Wrap a native material index.
     *
     * @param engine Engine instance.
     * @param index The index.
     * @returns Material instance or `null` if index <= 0.
     *
     * @deprecated Please use `new Material()` instead.
     */
    static wrap(engine, index) {
        /** @todo: this propagate nullable in the entire codebase. Remove. */
        return index > 0 ? new Material(engine, index) : null;
    }
}
/** Temporary canvas */
let temp2d = null;
/**
 * Wrapper around a native texture data.
 */
export class Texture {
    /** Wonderland Engine instance. @hidden */
    _engine;
    /** Index in the manager. @hidden */
    _id = 0;
    /** HTML image index. @hidden */
    _imageIndex = null;
    /**
     * @param engine The engine instance
     * @param param HTML media element to create texture from or texture id to wrap.
     */
    constructor(engine, param) {
        this._engine = engine ?? WL;
        const wasm = engine.wasm;
        if (param instanceof HTMLImageElement ||
            param instanceof HTMLVideoElement ||
            param instanceof HTMLCanvasElement) {
            const index = wasm._images.length;
            wasm._images.push(param);
            this._imageIndex = index;
            this._id = this._engine.wasm._wl_renderer_addImage(index);
        }
        else {
            this._id = param;
        }
        this._engine.textures._set(this);
    }
    /** Whether this texture is valid. */
    get valid() {
        return this._id >= 0;
    }
    /** Index in this manager. */
    get id() {
        return this._id;
    }
    /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
    update() {
        if (!this.valid || this._imageIndex === null)
            return;
        this._engine.wasm._wl_renderer_updateImage(this._id, this._imageIndex);
    }
    /** Width of the texture. */
    get width() {
        return this._engine.wasm._wl_texture_width(this._id);
    }
    /** Height of the texture. */
    get height() {
        return this._engine.wasm._wl_texture_height(this._id);
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /**
     * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
     *
     * Usage:
     *
     * ```js
     * // Copies rectangle of pixel starting from (10, 20)
     * texture.updateSubImage(10, 20, 600, 400);
     * ```
     *
     * @param x x offset
     * @param y y offset
     * @param w width
     * @param h height
     */
    updateSubImage(x, y, w, h) {
        if (!this.valid || this._imageIndex === null)
            return;
        /* Lazy initialize temp canvas */
        if (!temp2d) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                throw new Error('Texture.updateSubImage(): Failed to obtain CanvasRenderingContext2D.');
            }
            temp2d = { canvas, ctx };
        }
        const wasm = this._engine.wasm;
        const img = wasm._images[this._imageIndex];
        if (!img)
            return;
        temp2d.canvas.width = w;
        temp2d.canvas.height = h;
        temp2d.ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
        const yOffset = (img.videoHeight ?? img.height) - y - h;
        wasm._images[this._imageIndex] = temp2d.canvas;
        wasm._wl_renderer_updateImage(this._id, this._imageIndex, x, yOffset);
        wasm._images[this._imageIndex] = img;
    }
    /**
     * Destroy and free the texture's texture altas space and memory.
     *
     * It is best practice to set the texture variable to `null` after calling
     * destroy to prevent accidental use of the invalid texture:
     *
     * ```js
     *   texture.destroy();
     *   texture = null;
     * ```
     *
     * @since 0.9.0
     */
    destroy() {
        this.engine.textures._destroy(this);
        this._id = -1;
        this._imageIndex = null;
    }
    /**
     * Checks equality by comparing whether the wrapped native texture ids are
     * equal.
     *
     * @param otherTexture Texture to check equality with.
     * @returns Whether this texture equals the given texture.
     *
     * @since 1.0.0
     */
    equals(otherTexture) {
        if (!otherTexture)
            return false;
        return this._id === otherTexture._id;
    }
}
/**
 * Wrapper around a native animation.
 */
export class Animation {
    /** Index of the mesh in the manager. @hidden */
    _index;
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * @param index Index in the manager
     */
    constructor(engine = WL, index) {
        this._engine = engine;
        this._index = index;
    }
    /** Duration of this animation. */
    get duration() {
        return this._engine.wasm._wl_animation_get_duration(this._index);
    }
    /** Number of tracks in this animation. */
    get trackCount() {
        return this._engine.wasm._wl_animation_get_trackCount(this._index);
    }
    /**
     * Clone this animation retargeted to a new set of objects.
     *
     * The clone shares most of the data with the original and is therefore
     * light-weight.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * If retargeting to {@link Skin}, the join names will be used to determine a mapping
     * from the previous skin to the new skin. The source skin will be retrieved from
     * the first track in the animation that targets a joint.
     *
     * @param newTargets New targets per track. Expected to have
     *      {@link Animation#trackCount} elements or to be a {@link Skin}.
     * @returns The retargeted clone of this animation.
     */
    retarget(newTargets) {
        const wasm = this._engine.wasm;
        if (newTargets instanceof Skin) {
            const animId = wasm._wl_animation_retargetToSkin(this._index, newTargets._index);
            return new Animation(this._engine, animId);
        }
        if (newTargets.length != this.trackCount) {
            throw Error('Expected ' +
                this.trackCount.toString() +
                ' targets, but got ' +
                newTargets.length.toString());
        }
        const ptr = wasm._malloc(2 * newTargets.length);
        for (let i = 0; i < newTargets.length; ++i) {
            wasm.HEAPU16[ptr >> (1 + i)] = newTargets[i].objectId;
        }
        const animId = wasm._wl_animation_retarget(this._index, ptr);
        wasm._free(ptr);
        return new Animation(this._engine, animId);
    }
    /**
     * Checks equality by comparing whether the wrapped native animation ids
     * are equal.
     *
     * @param otherAnimation Animation to check equality with.
     * @returns Whether this animation equals the given animation.
     *
     * @since 1.0.0
     */
    equals(otherAnimation) {
        if (!otherAnimation)
            return false;
        return this._index === otherAnimation._index;
    }
}
/**
 * Scene graph object.
 *
 * Node in the scene graph or "entity". Consists of transformation and a reference
 * to its parent object. Usually holds components and is accessible by components
 * through {@link Component#object}.
 *
 * Objects are stored in a data oriented manner inside WebAssembly memory. This class
 * is a JavaScript API wrapper around this memory for more convenient use in
 * components.
 *
 * Objects can be created and added to a scene through
 * {@link Scene#addObject} on the {@link WonderlandEngine.scene}.
 */
export class Object3D {
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * Object index in the manager.
     *
     * @hidden
     */
    _objectId = -1;
    /**
     * @param o Object id to wrap
     *
     * For performance reasons, please use {@link WonderlandEngine.wrapObject}
     */
    constructor(engine, o) {
        this._objectId = o;
        this._engine = engine;
    }
    /**
     * Name of the object.
     *
     * Useful for identifying objects during debugging.
     */
    get name() {
        const wasm = this._engine.wasm;
        return wasm.UTF8ToString(wasm._wl_object_name(this.objectId));
    }
    /**
     * Set the object's name.
     *
     * @param newName The new name to set.
     */
    set name(newName) {
        const wasm = this._engine.wasm;
        wasm._wl_object_set_name(this.objectId, wasm.tempUTF8(newName));
    }
    /**
     * Parent of this object or `null` if parented to root.
     */
    get parent() {
        const p = this._engine.wasm._wl_object_parent(this.objectId);
        return p === 0 ? null : this._engine.wrapObject(p);
    }
    /**
     * Children of this object.
     */
    get children() {
        const childrenCount = this._engine.wasm._wl_object_get_children_count(this.objectId);
        if (childrenCount === 0)
            return [];
        const wasm = this._engine.wasm;
        wasm.requireTempMem(childrenCount * 2);
        this._engine.wasm._wl_object_get_children(this.objectId, wasm._tempMem, wasm._tempMemSize >> 1);
        const children = new Array(childrenCount);
        for (let i = 0; i < childrenCount; ++i) {
            children[i] = this._engine.wrapObject(wasm._tempMemUint16[i]);
        }
        return children;
    }
    /**
     * Reparent object to given object.
     *
     * @note Reparenting is not trivial and might have a noticeable performance impact.
     *
     * @param newParent New parent or `null` to parent to root
     */
    set parent(newParent) {
        this._engine.wasm._wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);
    }
    /** Object index in the manager. */
    get objectId() {
        return this._objectId;
    }
    /** Hosting engine instance. */
    get engine() {
        return this._engine;
    }
    /**
     * Reset local transformation (translation, rotation and scaling) to identity.
     *
     * @returns Reference to self (for method chaining).
     */
    resetTransform() {
        this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
        this._engine.wasm._wl_object_reset_scaling(this.objectId);
        return this;
    }
    /**
     * Reset local position and rotation to identity.
     *
     * @returns Reference to self (for method chaining).
     */
    resetPositionRotation() {
        this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
        return this;
    }
    /** @deprecated Please use {@link Object3D.resetPositionRotation} instead. */
    resetTranslationRotation() {
        return this.resetPositionRotation();
    }
    /**
     * Reset local rotation, keep translation.
     *
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     *
     * @returns Reference to self (for method chaining).
     */
    resetRotation() {
        this._engine.wasm._wl_object_reset_rotation(this.objectId);
        return this;
    }
    /**
     * Reset local translation, keep rotation.
     *
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     *
     * @returns Reference to self (for method chaining).
     */
    resetPosition() {
        this._engine.wasm._wl_object_reset_translation(this.objectId);
        return this;
    }
    /** @deprecated Please use {@link Object3D.resetPosition} instead. */
    resetTranslation() {
        return this.resetPosition();
    }
    /**
     * Reset local scaling to identity (``[1.0, 1.0, 1.0]``).
     *
     * @returns Reference to self (for method chaining).
     */
    resetScaling() {
        this._engine.wasm._wl_object_reset_scaling(this.objectId);
        return this;
    }
    /** @deprecated Please use {@link Object3D.translateLocal} instead. */
    translate(v) {
        return this.translateLocal(v);
    }
    /**
     * Translate object by a vector in the parent's space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateLocal(v) {
        this._engine.wasm._wl_object_translate(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    /**
     * Translate object by a vector in object space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateObject(v) {
        this._engine.wasm._wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    /**
     * Translate object by a vector in world space.
     *
     * @param v Vector to translate by.
     *
     * @returns Reference to self (for method chaining).
     */
    translateWorld(v) {
        this._engine.wasm._wl_object_translate_world(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    /** @deprecated Please use {@link Object3D.rotateAxisAngleDegLocal} instead. */
    rotateAxisAngleDeg(a, d) {
        this.rotateAxisAngleDegLocal(a, d);
        return this;
    }
    /**
     * Rotate around given axis by given angle (degrees) in local space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleRad}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleDegLocal(a, d) {
        this._engine.wasm._wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);
        return this;
    }
    /** @deprecated Please use {@link Object3D.rotateAxisAngleRadLocal} instead. */
    rotateAxisAngleRad(a, d) {
        return this.rotateAxisAngleRadLocal(a, d);
    }
    /**
     * Rotate around given axis by given angle (radians) in local space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in radians.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleDeg}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleRadLocal(a, d) {
        this._engine.wasm._wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);
        return this;
    }
    /**
     * Rotate around given axis by given angle (degrees) in object space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @see {@link rotateAxisAngleRadObject}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleDegObject(a, d) {
        this._engine.wasm._wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);
        return this;
    }
    /**
     * Rotate around given axis by given angle (radians) in object space
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param a Vector representing the rotation axis
     * @param d Angle in degrees
     *
     * @see {@link rotateAxisAngleDegObject}
     *
     * @returns Reference to self (for method chaining).
     */
    rotateAxisAngleRadObject(a, d) {
        this._engine.wasm._wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);
        return this;
    }
    /** @deprecated Please use {@link Object3D.rotateLocal} instead. */
    rotate(q) {
        this.rotateLocal(q);
        return this;
    }
    /**
     * Rotate by a quaternion.
     *
     * @param q the Quaternion to rotate by.
     *
     * @returns Reference to self (for method chaining).
     */
    rotateLocal(q) {
        this._engine.wasm._wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);
        return this;
    }
    /**
     * Rotate by a quaternion in object space.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param q the Quaternion to rotate by.
     *
     * @returns Reference to self (for method chaining).
     */
    rotateObject(q) {
        this._engine.wasm._wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);
        return this;
    }
    /** @deprecated Please use {@link Object3D.scaleLocal} instead. */
    scale(v) {
        this.scaleLocal(v);
        return this;
    }
    /**
     * Scale object by a vector in object space.
     *
     * @param v Vector to scale by.
     *
     * @returns Reference to self (for method chaining).
     */
    scaleLocal(v) {
        this._engine.wasm._wl_object_scale(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    getPositionLocal(out = new Float32Array(3)) {
        const wasm = this._engine.wasm;
        /* Translation is different than rotation & scaling.
         * We can't simply read the memory. */
        wasm._wl_object_get_translation_local(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    getTranslationLocal(out = new Float32Array(3)) {
        return this.getPositionLocal(out);
    }
    getPositionWorld(out = new Float32Array(3)) {
        const wasm = this._engine.wasm;
        /* Translation is different than rotation & scaling.
         * We can't simply read the memory. */
        wasm._wl_object_get_translation_world(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    getTranslationWorld(out = new Float32Array(3)) {
        return this.getPositionWorld(out);
    }
    /**
     * Set local / object space position.
     *
     * Concatenates a new translation dual quaternion onto the existing rotation.
     *
     * @param v New local position array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setPositionLocal(v) {
        this._engine.wasm._wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    /** @deprecated Please use {@link Object3D.setPositionLocal} instead. */
    setTranslationLocal(v) {
        return this.setPositionLocal(v);
    }
    /**
     * Set world space position.
     *
     * Applies the inverse parent transform with a new translation dual quaternion
     * which is concatenated onto the existing rotation.
     *
     * @param v New world position array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setPositionWorld(v) {
        this._engine.wasm._wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    /** @deprecated Please use {@link Object3D.setPositionWorld} instead. */
    setTranslationWorld(v) {
        return this.setPositionWorld(v);
    }
    getScalingLocal(out = new Float32Array(3)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_scaling_local(this.objectId) / 4; /* Align F32 */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        return out;
    }
    /**
     * Set local / object space scaling.
     *
     * @param v New local scaling array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setScalingLocal(v) {
        this._engine.wasm._wl_object_set_scaling_local(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    getScalingWorld(out = new Float32Array(3)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_scaling_world(this.objectId) / 4; /* Align F32 */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        return out;
    }
    /**
     * Set World space scaling.
     *
     * @param v New world scaling array/vector, expected to have at least 3 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setScalingWorld(v) {
        this._engine.wasm._wl_object_set_scaling_world(this.objectId, v[0], v[1], v[2]);
        return this;
    }
    getRotationLocal(out = new Float32Array(4)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_local(this.objectId) / 4; /* Align F32 */
        /* The first 4 floats represent the rotation quaternion. */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        out[3] = wasm.HEAPF32[ptr + 3];
        return out;
    }
    /**
     * Set local space rotation.
     *
     * @param v New world rotation array/vector, expected to have at least 4 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setRotationLocal(v) {
        this._engine.wasm._wl_object_set_rotation_local(this.objectId, v[0], v[1], v[2], v[3]);
        return this;
    }
    getRotationWorld(out = new Float32Array(4)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_world(this.objectId) / 4; /* Align F32 */
        /* The first 4 floats represent the rotation quaternion. */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        out[3] = wasm.HEAPF32[ptr + 3];
        return out;
    }
    /**
     * Set local space rotation.
     *
     * @param v New world rotation array/vector, expected to have at least 4 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setRotationWorld(v) {
        this._engine.wasm._wl_object_set_rotation_world(this.objectId, v[0], v[1], v[2], v[3]);
        return this;
    }
    getTransformLocal(out = new Float32Array(8)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_local(this.objectId) / 4; /* Align F32 */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        out[3] = wasm.HEAPF32[ptr + 3];
        out[4] = wasm.HEAPF32[ptr + 4];
        out[5] = wasm.HEAPF32[ptr + 5];
        out[6] = wasm.HEAPF32[ptr + 6];
        out[7] = wasm.HEAPF32[ptr + 7];
        return out;
    }
    /**
     * Set local space rotation.
     *
     * @param v New local transform array, expected to have at least 8 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setTransformLocal(v) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_local(this.objectId) / 4; /* Align F32 */
        wasm.HEAPF32[ptr] = v[0];
        wasm.HEAPF32[ptr + 1] = v[1];
        wasm.HEAPF32[ptr + 2] = v[2];
        wasm.HEAPF32[ptr + 3] = v[3];
        wasm.HEAPF32[ptr + 4] = v[4];
        wasm.HEAPF32[ptr + 5] = v[5];
        wasm.HEAPF32[ptr + 6] = v[6];
        wasm.HEAPF32[ptr + 7] = v[7];
        this.setDirty();
        return this;
    }
    getTransformWorld(out = new Float32Array(8)) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_world(this.objectId) / 4; /* Align F32 */
        out[0] = wasm.HEAPF32[ptr];
        out[1] = wasm.HEAPF32[ptr + 1];
        out[2] = wasm.HEAPF32[ptr + 2];
        out[3] = wasm.HEAPF32[ptr + 3];
        out[4] = wasm.HEAPF32[ptr + 4];
        out[5] = wasm.HEAPF32[ptr + 5];
        out[6] = wasm.HEAPF32[ptr + 6];
        out[7] = wasm.HEAPF32[ptr + 7];
        return out;
    }
    /**
     * Set world space rotation.
     *
     * @param v New world transform array, expected to have at least 8 elements.
     *
     * @returns Reference to self (for method chaining).
     */
    setTransformWorld(v) {
        const wasm = this._engine.wasm;
        const ptr = wasm._wl_object_trans_world(this.objectId) / 4; /* Align F32 */
        wasm.HEAPF32[ptr] = v[0];
        wasm.HEAPF32[ptr + 1] = v[1];
        wasm.HEAPF32[ptr + 2] = v[2];
        wasm.HEAPF32[ptr + 3] = v[3];
        wasm.HEAPF32[ptr + 4] = v[4];
        wasm.HEAPF32[ptr + 5] = v[5];
        wasm.HEAPF32[ptr + 6] = v[6];
        wasm.HEAPF32[ptr + 7] = v[7];
        this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
        return this;
    }
    /**
     * Local space transformation.
     *
     * @deprecated Please use {@link Object3D.setTransformLocal} and
     * {@link Object3D.getTransformLocal} instead.
     */
    get transformLocal() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_local(this.objectId), 8);
    }
    /**
     * Set local transform.
     *
     * @param t Local space transformation.
     *
     * @since 0.8.5
     *
     * @deprecated Please use {@link Object3D.setTransformLocal} and
     * {@link Object3D.getTransformLocal} instead.
     */
    set transformLocal(t) {
        this.transformLocal.set(t);
        this.setDirty();
    }
    /**
     * Global / world space transformation.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @deprecated Please use {@link Object3D.setTransformWorld} and
     * {@link Object3D.getTransformWorld} instead.
     */
    get transformWorld() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_world(this.objectId), 8);
    }
    /**
     * Set world transform.
     *
     * @param t Global / world space transformation.
     *
     * @since 0.8.5
     *
     * @deprecated Please use {@link Object3D.setTransformWorld} and
     * {@link Object3D.getTransformWorld} instead.
     */
    set transformWorld(t) {
        this.transformWorld.set(t);
        this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
    }
    /**
     * Local / object space scaling.
     *
     * @deprecated Please use {@link Object3D.setScalingLocal} and
     * {@link Object3D.getScalingLocal} instead.
     */
    get scalingLocal() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_local(this.objectId), 3);
    }
    /**
     * Set local space scaling.
     *
     * @param s Local space scaling.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.setScalingLocal} and
     * {@link Object3D.getScalingLocal} instead.
     */
    set scalingLocal(s) {
        this.scalingLocal.set(s);
        this.setDirty();
    }
    /**
     * Global / world space scaling.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @deprecated Please use {@link Object3D.setScalingWorld} and
     * {@link Object3D.getScalingWorld} instead.
     */
    get scalingWorld() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_world(this.objectId), 3);
    }
    /**
     * Set world space scaling.
     *
     * @param t World space scaling.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.setScalingWorld} and
     * {@link Object3D.getScalingWorld} instead.
     */
    set scalingWorld(s) {
        this.scalingWorld.set(s);
        this._engine.wasm._wl_object_scaling_world_to_local(this.objectId);
    }
    /**
     * Local space rotation.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationLocal} and
     * {@link Object3D.setRotationLocal} instead.
     */
    get rotationLocal() {
        return this.transformLocal.subarray(0, 4);
    }
    /**
     * Global / world space rotation
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationWorld} and
     * {@link Object3D.setRotationWorld} instead.
     */
    get rotationWorld() {
        return this.transformWorld.subarray(0, 4);
    }
    /**
     * Set local space rotation.
     *
     * @param r Local space rotation
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationLocal} and
     * {@link Object3D.setRotationLocal} instead.
     */
    set rotationLocal(r) {
        this._engine.wasm._wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);
    }
    /**
     * Set world space rotation.
     *
     * @param r Global / world space rotation.
     *
     * @since 0.8.7
     *
     * @deprecated Please use {@link Object3D.getRotationWorld} and
     * {@link Object3D.setRotationWorld} instead.
     */
    set rotationWorld(r) {
        this._engine.wasm._wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);
    }
    /** @deprecated Please use {@link Object3D.getForwardWorld} instead. */
    getForward(out) {
        return this.getForwardWorld(out);
    }
    /**
     * Compute the object's forward facing world space vector.
     *
     * The forward vector in object space is along the negative z-axis, i.e.,
     * `[0, 0, -1]`.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getForwardWorld(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = -1;
        this.transformVectorWorld(out);
        return out;
    }
    /** @deprecated Please use {@link Object3D.getUpWorld} instead. */
    getUp(out) {
        return this.getUpWorld(out);
    }
    /**
     * Compute the object's up facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getUpWorld(out) {
        out[0] = 0;
        out[1] = 1;
        out[2] = 0;
        this.transformVectorWorld(out);
        return out;
    }
    /** @deprecated Please use {@link Object3D.getRightWorld} instead. */
    getRight(out) {
        return this.getRightWorld(out);
    }
    /**
     * Compute the object's right facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getRightWorld(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        this.transformVectorWorld(out);
        return out;
    }
    /**
     * Transform a vector by this object's world transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorWorld(out, v = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = v[0];
        wasm._tempMemFloat[1] = v[1];
        wasm._tempMemFloat[2] = v[2];
        wasm._wl_object_transformVectorWorld(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a vector by this object's local transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorLocal(out, v = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = v[0];
        wasm._tempMemFloat[1] = v[1];
        wasm._tempMemFloat[2] = v[2];
        wasm._wl_object_transformVectorLocal(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a point by this object's world transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointWorld(out, p = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = p[0];
        wasm._tempMemFloat[1] = p[1];
        wasm._tempMemFloat[2] = p[2];
        wasm._wl_object_transformPointWorld(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a point by this object's local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointLocal(out, p = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = p[0];
        wasm._tempMemFloat[1] = p[1];
        wasm._tempMemFloat[2] = p[2];
        wasm._wl_object_transformPointLocal(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a vector by this object's inverse world transform.
     *
     * @param out Out vector.
     * @param v Vector to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseWorld(out, v = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = v[0];
        wasm._tempMemFloat[1] = v[1];
        wasm._tempMemFloat[2] = v[2];
        wasm._wl_object_transformVectorInverseWorld(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a vector by this object's inverse local transform.
     *
     * @param out Out vector
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseLocal(out, v = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = v[0];
        wasm._tempMemFloat[1] = v[1];
        wasm._tempMemFloat[2] = v[2];
        wasm._wl_object_transformVectorInverseLocal(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a point by this object's inverse world transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseWorld(out, p = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat[0] = p[0];
        wasm._tempMemFloat[1] = p[1];
        wasm._tempMemFloat[2] = p[2];
        wasm._wl_object_transformPointInverseWorld(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform a point by this object's inverse local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseLocal(out, p = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat.set(p);
        wasm._wl_object_transformPointInverseLocal(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        return out;
    }
    /**
     * Transform an object space dual quaternion into world space.
     *
     * @param out Out transformation.
     * @param q Local space transformation, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toWorldSpaceTransform(out, q = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat.set(q);
        wasm._wl_object_toWorldSpaceTransform(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        out[3] = wasm._tempMemFloat[3];
        out[4] = wasm._tempMemFloat[4];
        out[5] = wasm._tempMemFloat[5];
        out[6] = wasm._tempMemFloat[6];
        out[7] = wasm._tempMemFloat[7];
        return out;
    }
    /**
     * Transform a world space dual quaternion into local space.
     *
     * @param out Out transformation
     * @param q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toLocalSpaceTransform(out, q = out) {
        const p = this.parent;
        if (p) {
            p.toObjectSpaceTransform(out, q);
            return out;
        }
        if (out !== q) {
            out[0] = q[0];
            out[1] = q[1];
            out[2] = q[2];
            out[3] = q[3];
            out[4] = q[4];
            out[5] = q[5];
            out[6] = q[6];
            out[7] = q[7];
        }
        return out;
    }
    /**
     * Transform a world space dual quaternion into object space.
     *
     * @param out Out transformation.
     * @param q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toObjectSpaceTransform(out, q = out) {
        const wasm = this._engine.wasm;
        wasm._tempMemFloat.set(q);
        wasm._wl_object_toObjectSpaceTransform(this.objectId, wasm._tempMem);
        out[0] = wasm._tempMemFloat[0];
        out[1] = wasm._tempMemFloat[1];
        out[2] = wasm._tempMemFloat[2];
        out[3] = wasm._tempMemFloat[3];
        out[4] = wasm._tempMemFloat[4];
        out[5] = wasm._tempMemFloat[5];
        out[6] = wasm._tempMemFloat[6];
        out[7] = wasm._tempMemFloat[7];
        return out;
    }
    /**
     * Turn towards / look at target.
     *
     * Rotates the object so that its forward vector faces towards the target
     * position. The `up` vector acts as a hint to uniquely orient the object's
     * up direction. When orienting a view component, the projected `up` vector
     * faces upwards on the viewing plane.
     *
     * @param p Target position to turn towards, in world space.
     * @param up Up vector to align object with, in world space. Default is `[0, 1, 0]`.
     *
     * @returns Reference to self (for method chaining).
     */
    lookAt(p, up = UP_VECTOR) {
        this._engine.wasm._wl_object_lookAt(this.objectId, p[0], p[1], p[2], up[0], up[1], up[2]);
        return this;
    }
    /** Destroy the object with all of its components and remove it from the scene */
    destroy() {
        this._engine.wasm._wl_scene_remove_object(this.objectId);
        this._objectId = -1;
    }
    /**
     * Mark transformation dirty.
     *
     * Causes an eventual recalculation of {@link transformWorld}, either
     * on next {@link getTranslationWorld}, {@link transformWorld} or
     * {@link scalingWorld} or the beginning of next frame, whichever
     * happens first.
     */
    setDirty() {
        this._engine.wasm._wl_object_set_dirty(this.objectId);
    }
    /**
     * Disable/enable all components of this object.
     *
     * @param b New state for the components.
     *
     * @since 0.8.5
     */
    set active(b) {
        const comps = this.getComponents();
        for (let c of comps) {
            c.active = b;
        }
    }
    getComponent(typeOrClass, index = 0) {
        const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
        const wasm = this._engine.wasm;
        const componentType = wasm._wl_get_component_manager_index(wasm.tempUTF8(type));
        if (componentType < 0) {
            /* Not a native component, try js: */
            const typeIndex = wasm._componentTypeIndices[type];
            if (typeIndex === undefined)
                return null;
            const jsIndex = wasm._wl_get_js_component_index(this.objectId, typeIndex, index);
            return jsIndex < 0 ? null : this._engine.wasm._components[jsIndex];
        }
        const componentId = this._engine.wasm._wl_get_component_id(this.objectId, componentType, index);
        return this._engine._wrapComponent(type, componentType, componentId);
    }
    /**
     * @param typeOrClass Type name, pass a falsey value (`undefined` or `null`) to retrieve all.
     *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to
     *     find the components.
     * @returns All components of given type attached to this object.
     *
     * @note As this function is non-trivial, avoid using it in `update()` repeatedly,
     *      but rather store its result in `init()` or `start()`
     * @warning This method will currently return at most 341 components.
     */
    getComponents(typeOrClass) {
        const wasm = this._engine.wasm;
        let componentType = null;
        let type = null;
        if (typeOrClass) {
            type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
            componentType = wasm._typeIndexFor(type);
        }
        const components = [];
        const maxComps = Math.floor((wasm._tempMemSize / 3) * 2);
        const componentsCount = wasm._wl_object_get_components(this.objectId, wasm._tempMem, maxComps);
        const offset = 2 * componentsCount;
        wasm._wl_object_get_component_types(this.objectId, wasm._tempMem + offset, maxComps);
        const jsManagerIndex = wasm._typeIndexFor('js');
        for (let i = 0; i < componentsCount; ++i) {
            const t = wasm._tempMemUint8[i + offset];
            const componentId = wasm._tempMemUint16[i];
            /* Handle JS types separately */
            if (t == jsManagerIndex) {
                const typeIndex = wasm._wl_get_js_component_index_for_id(componentId);
                const comp = wasm._components[typeIndex];
                if (componentType === null || comp.type == type)
                    components.push(comp);
                continue;
            }
            if (componentType === null) {
                const managerName = wasm._typeNameFor(t);
                components.push(this._engine._wrapComponent(managerName, t, componentId));
            }
            else if (t == componentType) {
                /* Optimized manager name retrieval, already have type */
                components.push(this._engine._wrapComponent(type, componentType, componentId));
            }
        }
        return components;
    }
    addComponent(typeOrClass, params) {
        const wasm = this._engine.wasm;
        const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
        const componentType = wasm._typeIndexFor(type);
        let component = null;
        let componentIndex = null;
        if (componentType < 0) {
            /* JavaScript component */
            if (!(type in wasm._componentTypeIndices)) {
                throw new TypeError("Unknown component type '" + type + "'");
            }
            const componentId = wasm._wl_object_add_js_component(this.objectId, wasm._componentTypeIndices[type]);
            componentIndex = wasm._wl_get_js_component_index_for_id(componentId);
            component = wasm._components[componentIndex];
        }
        else {
            /* native component */
            const componentId = wasm._wl_object_add_component(this.objectId, componentType);
            component = this._engine._wrapComponent(type, componentType, componentId);
        }
        if (params !== undefined) {
            const ctor = component.constructor;
            for (const key in params) {
                if (!(key in ctor.Properties))
                    continue;
                component[key] = params[key];
            }
        }
        /* Explicitly initialize native components */
        if (componentType < 0) {
            /* @todo: `componentIndex` can be null here, that's an error */
            wasm._wljs_component_init(componentIndex);
            /* start() is called through onActivate() */
        }
        /* If it was not explicitly requested by the user to leave the component inactive,
         * we activate it as a final step. This invalidates componentIndex! */
        if (!params || !('active' in params && !params.active)) {
            component.active = true;
        }
        return component;
    }
    /**
     * Whether given object's transformation has changed.
     */
    get changed() {
        return !!this._engine.wasm._wl_object_is_changed(this.objectId);
    }
    /**
     * Checks equality by comparing whether the wrapped native object ids are
     * equal.
     *
     * @param otherObject Object to check equality with.
     * @returns Whether this object equals the given object.
     */
    equals(otherObject) {
        if (!otherObject)
            return false;
        return this.objectId == otherObject.objectId;
    }
}
/**
 * Wrapper around a native skin data.
 */
export class Skin {
    /**
     * Index of the skin in the manager.
     * @hidden
     */
    _index;
    /** Wonderland Engine instance. @hidden */
    _engine;
    constructor(engine, index) {
        this._engine = engine;
        this._index = index;
    }
    /** Amount of joints in this skin. */
    get jointCount() {
        return this._engine.wasm._wl_skin_get_joint_count(this._index);
    }
    /** Joints object ids for this skin */
    get jointIds() {
        const wasm = this._engine.wasm;
        return new Uint16Array(wasm.HEAPU16.buffer, wasm._wl_skin_joint_ids(this._index), this.jointCount);
    }
    /**
     * Dual quaternions in a flat array of size 8 times {@link jointCount}.
     *
     * Inverse bind transforms of the skin.
     */
    get inverseBindTransforms() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_transforms(this._index), 8 * this.jointCount);
    }
    /**
     * Vectors in a flat array of size 3 times {@link jointCount}.
     *
     * Inverse bind scalings of the skin.
     */
    get inverseBindScalings() {
        const wasm = this._engine.wasm;
        return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_scalings(this._index), 3 * this.jointCount);
    }
    /**
     * Checks equality by comparing whether the wrapped native skin ids are
     * equal.
     *
     * @param otherSkin Skin to check equality with.
     * @returns Whether this skin equals the given skin.
     *
     * @since 1.0.0
     */
    equals(otherSkin) {
        if (!otherSkin)
            return false;
        return this._index === otherSkin._index;
    }
}
/* For backward compatibility with < 1.0.0. */
export { Object3D as Object };
/**
 * Ray hit.
 *
 * Result of a {@link Scene.rayCast}.
 *
 * @note this class wraps internal engine data and should only be created internally.
 */
export class RayHit {
    /** Wonderland Engine instance. @hidden */
    _engine;
    /** Pointer to the memory heap. */
    _ptr;
    /**
     * @param ptr Pointer to the ray hits memory.
     */
    constructor(engine, ptr) {
        if ((ptr & 3) !== 0) {
            throw new Error('Misaligned pointer: please report a bug');
        }
        this._engine = engine;
        this._ptr = ptr;
    }
    /** Array of ray hit locations. */
    get locations() {
        let p = this._ptr;
        let l = [];
        for (let i = 0; i < this.hitCount; ++i) {
            l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
        }
        return l;
    }
    /** Array of ray hit normals (only when using {@link Physics#rayCast}. */
    get normals() {
        let p = this._ptr + 48;
        let l = [];
        for (let i = 0; i < this.hitCount; ++i) {
            l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
        }
        return l;
    }
    /**
     * Prefer these to recalculating the distance from locations.
     *
     * Distances of array hits to ray origin.
     */
    get distances() {
        const p = this._ptr + 48 * 2;
        return new Float32Array(this._engine.wasm.HEAPF32.buffer, p, this.hitCount);
    }
    /** Hit objects */
    get objects() {
        const HEAPU16 = this._engine.wasm.HEAPU16;
        const objects = [null, null, null, null];
        let p = (this._ptr + (48 * 2 + 16)) >> 1;
        for (let i = 0; i < this.hitCount; ++i) {
            objects[i] = this._engine.wrapObject(HEAPU16[p + i]);
        }
        return objects;
    }
    /** Number of hits (max 4) */
    get hitCount() {
        return Math.min(this._engine.wasm.HEAPU32[this._ptr / 4 + 30], 4);
    }
}
class math {
    /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.
     *
     * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.
     *
     * Whether a quaternion or vector3 interpolation is intended is determined by
     * length of `a`.
     *
     * @param out Array to write result to.
     * @param a First tangent/handle.
     * @param b First point or quaternion.
     * @param c Second point or quaternion.
     * @param d Second handle.
     * @param f Interpolation factor in [0; 1].
     * @returns The `out` parameter.
     *
     * @since 0.8.6
     */
    static cubicHermite(out, a, b, c, d, f, engine = WL) {
        const wasm = engine.wasm;
        wasm._tempMemFloat.subarray(0).set(a);
        wasm._tempMemFloat.subarray(4).set(b);
        wasm._tempMemFloat.subarray(8).set(c);
        wasm._tempMemFloat.subarray(12).set(d);
        const isQuat = a.length == 4;
        wasm._wl_math_cubicHermite(wasm._tempMem + 4 * 16, wasm._tempMem + 4 * 0, wasm._tempMem + 4 * 4, wasm._tempMem + 4 * 8, wasm._tempMem + 4 * 12, f, isQuat);
        out[0] = wasm._tempMemFloat[16];
        out[1] = wasm._tempMemFloat[17];
        out[2] = wasm._tempMemFloat[18];
        if (isQuat)
            out[3] = wasm._tempMemFloat[19];
        return out;
    }
}
export { math };
/**
 * Class for accessing internationalization (i18n) features.
 *
 * Allows {@link I18N.onLanguageChanged "detecting language change"},
 * {@link I18N.language "setting the current language"} or translating
 * {@link I18N.translate() "individual terms"}.
 *
 * Internationalization works with terms,
 * a string type keyword that is linked to a different text for each language.
 *
 * Internally, string parameters for text and js components are
 * automatically swapped during language change, given they are linked to a term.
 * If manual text swapping is desired, {@link I18N.translate()}
 * can be used to retrieve the current translation for any term.
 *
 * You can also use the {@link I18N.onLanguageChanged} to manually update text
 * when a language is changed to for example update a number in a string.
 *
 * @since 1.0.0
 */
export class I18N {
    /**
     * {@link Emitter} for language change events.
     *
     * First parameter to a listener is the old language index,
     * second parameter is the new language index.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.i18n.onLanguageChanged.add((oldLanguageIndex, newLanguageIndex) => {
     *     const oldLanguage = this.engine.i18n.languageName(oldLanguageIndex);
     *     const newLanguage = this.engine.i18n.languageName(newLanguageIndex);
     *     console.log("Switched from", oldLanguage, "to", newLanguage);
     * });
     * ```
     */
    onLanguageChanged = new Emitter();
    /** Wonderland Engine instance. @hidden */
    _engine;
    /**
     * Constructor
     */
    constructor(engine) {
        this._engine = engine;
    }
    /**
     * Set current language and apply translations to linked text parameters.
     *
     * @param code Language code to switch to
     */
    set language(code) {
        if (code == null)
            return;
        const wasm = this._engine.wasm;
        wasm._wl_i18n_setLanguage(wasm.tempUTF8(code));
    }
    /**
     * Get current language code.
     *
     */
    get language() {
        const wasm = this._engine.wasm;
        const code = wasm._wl_i18n_currentLanguage();
        if (code === 0)
            return null;
        return wasm.UTF8ToString(code);
    }
    /**
     * Get translated string for a term for the currently loaded language.
     *
     * @param term Term to translate
     */
    translate(term) {
        const wasm = this._engine.wasm;
        const translation = wasm._wl_i18n_translate(wasm.tempUTF8(term));
        if (translation === 0)
            return null;
        return wasm.UTF8ToString(translation);
    }
    /**
     * Get the number of languages in the project.
     *
     */
    languageCount() {
        const wasm = this._engine.wasm;
        return wasm._wl_i18n_languageCount();
    }
    /**
     * Get a language code.
     *
     * @param index Index of the language to get the code from
     */
    languageIndex(code) {
        const wasm = this._engine.wasm;
        return wasm._wl_i18n_languageIndex(wasm.tempUTF8(code));
    }
    /**
     * Get a language code.
     *
     * @param index Index of the language to get the code from
     */
    languageCode(index) {
        const wasm = this._engine.wasm;
        const code = wasm._wl_i18n_languageCode(index);
        if (code === 0)
            return null;
        return wasm.UTF8ToString(code);
    }
    /**
     * Get a language name.
     *
     * @param index Index of the language to get the name from
     */
    languageName(index) {
        const wasm = this._engine.wasm;
        const name = wasm._wl_i18n_languageName(index);
        if (name === 0)
            return null;
        return wasm.UTF8ToString(name);
    }
}
/** Properties of a WebXR session */
export class XR {
    /** Wonderland WASM bridge. @hidden */
    #wasm;
    #mode;
    constructor(wasm, mode) {
        this.#wasm = wasm;
        this.#mode = mode;
    }
    /** Current WebXR session mode */
    get sessionMode() {
        return this.#mode;
    }
    /** Current WebXR session */
    get session() {
        return this.#wasm.webxr_session;
    }
    /** Current WebXR frame */
    get frame() {
        return this.#wasm.webxr_frame;
    }
    referenceSpaceForType(type) {
        return this.#wasm.webxr_refSpaces[type] ?? null;
    }
    /** Set current reference space type used for retrieving eye, head, hand and joint poses */
    set currentReferenceSpace(refSpace) {
        this.#wasm.webxr_refSpace = refSpace;
        this.#wasm.webxr_refSpaceType = null;
        for (const type of Object.keys(this.#wasm.webxr_refSpaces)) {
            if (this.#wasm.webxr_refSpaces[type] === refSpace) {
                /* Keep track of reference space type */
                this.#wasm.webxr_refSpaceType = type;
            }
        }
    }
    /** Current reference space type used for retrieving eye, head, hand and joint poses */
    get currentReferenceSpace() {
        return this.#wasm.webxr_refSpace;
    }
    /** Current WebXR reference space type or `null` if not a default reference space */
    get currentReferenceSpaceType() {
        return this.#wasm.webxr_refSpaceType;
    }
    /** Current WebXR base layer  */
    get baseLayer() {
        return this.#wasm.webxr_baseLayer;
    }
    /** Current WebXR framebuffer */
    get framebuffers() {
        if (!Array.isArray(this.#wasm.webxr_fbo)) {
            return [this.#wasm.GL.framebuffers[this.#wasm.webxr_fbo]];
        }
        return this.#wasm.webxr_fbo.map((id) => this.#wasm.GL.framebuffers[id]);
    }
}
